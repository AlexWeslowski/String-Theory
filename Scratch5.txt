L'Hopital's Rule
x, n, i = sympy.symbols("x n i")
sympy.Derivative("(1/n)*log(cos(x) + i * sin(x)) - log(1 + (x*i)/n)", "n").doit() = i*x/(n**2*(i*x/n + 1)) - log(i*sin(x) + cos(x))/n**2
sympy.Derivative("(1/n)*log(1 + (x*i)/n)", "n").doit()                            = -i*x/(n**3*(i*x/n + 1)) - log(i*x/n + 1)/n**2

(i*x/(n**2*(i*x/n + 1)) - log(i*sin(x) + cos(x))/n**2) / (-i*x/(n**3*(i*x/n + 1)) - log(i*x/n + 1)/n**2)

sympy.simplify(sympy.expand("(i*x/(n**2*(i*x/n + 1)) - log(i*sin(x) + cos(x))/n**2) / (-i*x/(n**3*(i*x/n + 1)) - log(i*x/n + 1)/n**2)"))
(-i*n*x + i*x*log(i*sin(x) + cos(x)) + n*log(i*sin(x) + cos(x)))/(i*x*log((i*x + n)/n) + i*x + n*log((i*x + n)/n))
(-i*x + i*x*log(i*sin(x) + cos(x))/n + log(i*sin(x) + cos(x)))/(i*x*log((i*x + n)/n)/n + i*x/n + log((i*x + n)/n))

sympy.Derivative("(-i*x + i*x*log(i*sin(x) + cos(x))/n + log(i*sin(x) + cos(x)))", "n").doit() = -i*x*log(i*sin(x) + cos(x))/n**2
sympy.Derivative("(i*x*log((i*x + n)/n)/n + i*x/n + log((i*x + n)/n))", "n").doit()            = i*x*(1/n - (i*x + n)/n**2)/(i*x + n) - i*x*log((i*x + n)/n)/n**2 - i*x/n**2 + n*(1/n - (i*x + n)/n**2)/(i*x + n)

(-i*x*log(i*sin(x) + cos(x))/n**2) / (i*x*(1/n - (i*x + n)/n**2)/(i*x + n) - i*x*log((i*x + n)/n)/n**2 - i*x/n**2 + n*(1/n - (i*x + n)/n**2)/(i*x + n))
sympy.simplify(sympy.expand("(-i*x*log(i*sin(x) + cos(x))/n**2) / (i*x*(1/n - (i*x + n)/n**2)/(i*x + n) - i*x*log((i*x + n)/n)/n**2 - i*x/n**2 + n*(1/n - (i*x + n)/n**2)/(i*x + n))"))

log(i*sin(x) + cos(x))/(log((i*x + n)/n) + 2)
eps = log(i*sin(x) + cos(x))/(log(i*x/n + 1) + 2)
    = log(i*sin(x) + cos(x))/(log(1) + 2)
    = log(i*sin(x) + cos(x))/2

mpmath.log(mpmath.mpc(0, 1)*mpmath.sin(0.1234) + mpmath.cos(0.1234))
mpc(real='-9.2055087269362009669408922640471764737243e-40', imag='0.12339999999999999580335696691690827719904')
mpmath.log(mpmath.mpc(0, 1)*mpmath.sin(0.5678) + mpmath.cos(0.5678))
mpc(real='-1.3409101314165876081618461342841577406256e-39', imag='0.56779999999999997140065488565596751868725')

eps = i*x/2
(1 + (x*i)/n)^(n + eps) = cos(x) + i * sin(x)
(1 + (x*i)/n)^(n + x*i/2) = cos(x) + i * sin(x)



(1 + x/n)^(n + eps) = z
(n + eps)*log(1 + x/n) = log(z)
eps*log(1 + x/n) = log(z) - n*log(1 + x/n)
eps = (log(z) - n*log(1 + x/n))/log(1 + x/n)
    = ((1/n)*log(z) - log(1 + x/n))/((1/n)*log(1 + x/n))

L'Hopital's Rule
z, x, n = sympy.symbols("z x n")
sympy.Derivative("(1/n)*log(z) - log(1 + x/n)", "n").doit() = x/(n**2*(1 + x/n)) - log(z)/n**2
sympy.Derivative("(1/n)*log(1 + x/n)", "n").doit()          = -log(1 + x/n)/n**2 - x/(n**3*(1 + x/n))

sympy.simplify(sympy.expand("(x/(n**2*(1 + x/n)) - log(z)/n**2) / (-log(1 + x/n)/n**2 - x/(n**3*(1 + x/n)))"))
(-n*x + n*log(z) + x*log(z))/(n*log((n + x)/n) + x*log((n + x)/n) + x)
(-x + log(z) + (x/n)*log(z))/(log((n + x)/n) + (x/n)*log((n + x)/n) + x/n)

sympy.Derivative("-x + log(z) + (x/n)*log(z)", "n").doit()                  = -x*log(z)/n**2
sympy.Derivative("log((n + x)/n) + (x/n)*log((n + x)/n) + x/n", "n").doit() = n*(1/n - (n + x)/n**2)/(n + x) + x*(1/n - (n + x)/n**2)/(n + x) - x*log((n + x)/n)/n**2 - x/n**2

sympy.simplify(sympy.expand("(-x*log(z)/n**2) / (n*(1/n - (n + x)/n**2)/(n + x) + x*(1/n - (n + x)/n**2)/(n + x) - x*log((n + x)/n)/n**2 - x/n**2)"))
log(z)/(log((n + x)/n) + 2)
log(z)/(log(1 + x/n) + 2)
log(z)/2

approx_z = lambda x, n, z: mpmath.power(1 + mpmath.fdiv(x, n), n + mpmath.fdiv(mpmath.log(z), 2))
approx_z(100, 2**32, 2)
approx_z(mpmath.log(20), 2**16, 20)
mpf('20.000000010432251086181570156266440046959')


n, eps, x = sympy.symbols("n eps x")
f1 = sympy.expand("(n + eps)*log(1 + (x*i)/n)")
eps*log(i*x/n + 1) + n*log(i*x/n + 1)
f1.diff("x")
eps*i/(n*(i*x/n + 1)) + i/(i*x/n + 1)
f2 = sympy.expand("log(cos(x) + i * sin(x))")
log(i*sin(x) + cos(x))
f2.diff("x")
(i*cos(x) - sin(x))/(i*sin(x) + cos(x))

assuming (d/dx) log(i*sin(x) + cos(x)) = i:
eps*i/(n*(i*x/n + 1)) + i/(i*x/n + 1) = i
eps/(n*(i*x/n + 1)) + 1/(i*x/n + 1) = 1
eps/(n*(i*x/n + 1)) = 1 - 1/(i*x/n + 1)
eps = (n*(i*x/n + 1)) * (1 - 1/(i*x/n + 1))
eps = n*(i*x/n + 1) - n
eps = i*x


e^(i * x + eps) = cos(x) + i * sin(x)
(d/dx) (i * x + eps) = (d/dx) log(cos(x) + i * sin(x))
i = i

e^(i * x) = cos(x + eps) + i * sin(x + eps)



e^(ln(z)*(a+bi)) = (1 + (ln(z)*(a+bi))/n)^n * (1 + (ln(x)*(a+bi))/n)^(z/2)
e^x1 = (1 + x1/n1)^n1 * (1 + x1/n1)^(z/2)
e^x1 = (1 + x1/n1)^2*n1 * (1 + x1/n1)^(z/(2*n1))

z, a, b, n, i = sympy.symbols("z a b n i")
z, a, b, n, i = 4, 0.75, 41, 17, 1j
sympy.expand("(1 + (ln(z)*(a+b*i))/n)^n * (1 + (ln(x)*(a+bi))/n)^(z/2)")

z, pow_re, pow_im, n, i = sympy.symbols("z pow_im pow_re n i")
sympy.expand("(1 + (ln(z)*(pow1 + pow2))/n)^n * (1 + (ln(x)*(pow1 + pow2))/n)^(z/2)")

(1 + pow_re*log(z)/n + pow_im*log(z)/n)**n * (1 + pow_re*log(z)/n + pow_im*log(x)/n)**(z/2)

sympy.simplify(sympy.expand("(1 + (ln(z)*(pow_re + pow_im))/n)^(z/2)"))
for i in [3, 5, 7]:
    s = str(sympy.simplify(sympy.expand("(1 + (ln(" + str(i) + ")*(pow_re + pow_im))/3)^(" + str(i) + "/2)")))
    for j in range(2, i + 1):
        s = s.replace("/" + str(i**j), "/" + str(i) + "^" + str(j))
    print(s)
sympy.simplify(sympy.expand())

sqrt(3)*sqrt(pow_im*log(5) + pow_re*log(5) + 3)*(pow_im**2*log(5)**2 + 2*pow_im*pow_re*log(5)**2 + pow_im*log(15625) + pow_re**2*log(5)**2 + pow_re*log(15625) + 9)/27

for i in [3, 5, 7]:
    s = str(sympy.simplify(sympy.expand("(1 + pow_re*log(z)/" + str(i) + " + pow_im*log(z)/" + str(i) + ")**" + str(i) + "")))
    for j in range(2, i + 1):
        s = s.replace("/" + str(i**j), "/" + str(i) + "^" + str(j))
    print(s)
pow_im**3*log(z)**3/3^3 + pow_im**2*pow_re*log(z)**3/3^2 + pow_im**2*log(z)**2/3 + pow_im*pow_re**2*log(z)**3/3^2 + 2*pow_im*pow_re*log(z)**2/3 + pow_im*log(z) + pow_re**3*log(z)**3/3^3 + pow_re**2*log(z)**2/3 + pow_re*log(z) + 1
pow_im**5*log(z)**5/5^5 + pow_im**4*pow_re*log(z)**5/5^4 + pow_im**4*log(z)**4/5^3 + 2*pow_im**3*pow_re**2*log(z)**5/5^4 + 4*pow_im**3*pow_re*log(z)**4/5^3 + 2*pow_im**3*log(z)**3/5^2 + 2*pow_im**2*pow_re**3*log(z)**5/5^4 + 6*pow_im**2*pow_re**2*log(z)**4/5^3 + 6*pow_im**2*pow_re*log(z)**3/5^2 + 2*pow_im**2*log(z)**2/5 + pow_im*pow_re**4*log(z)**5/5^4 + 4*pow_im*pow_re**3*log(z)**4/5^3 + 6*pow_im*pow_re**2*log(z)**3/5^2 + 4*pow_im*pow_re*log(z)**2/5 + pow_im*log(z) + pow_re**5*log(z)**5/5^5 + pow_re**4*log(z)**4/5^3 + 2*pow_re**3*log(z)**3/5^2 + 2*pow_re**2*log(z)**2/5 + pow_re*log(z) + 1
pow_im**7*log(z)**7/7^7 + pow_im**6*pow_re*log(z)**7/7^6 + pow_im**6*log(z)**6/7^5 + 3*pow_im**5*pow_re**2*log(z)**7/7^6 + 6*pow_im**5*pow_re*log(z)**6/7^5 + 3*pow_im**5*log(z)**5/7^4 + 5*pow_im**4*pow_re**3*log(z)**7/7^6 + 15*pow_im**4*pow_re**2*log(z)**6/7^5 + 15*pow_im**4*pow_re*log(z)**5/7^4 + 5*pow_im**4*log(z)**4/7^3 + 5*pow_im**3*pow_re**4*log(z)**7/7^6 + 20*pow_im**3*pow_re**3*log(z)**6/7^5 + 30*pow_im**3*pow_re**2*log(z)**5/7^4 + 20*pow_im**3*pow_re*log(z)**4/7^3 + 5*pow_im**3*log(z)**3/7^2 + 3*pow_im**2*pow_re**5*log(z)**7/7^6 + 15*pow_im**2*pow_re**4*log(z)**6/7^5 + 30*pow_im**2*pow_re**3*log(z)**5/7^4 + 30*pow_im**2*pow_re**2*log(z)**4/7^3 + 15*pow_im**2*pow_re*log(z)**3/7^2 + 3*pow_im**2*log(z)**2/7 + pow_im*pow_re**6*log(z)**7/7^6 + 6*pow_im*pow_re**5*log(z)**6/7^5 + 15*pow_im*pow_re**4*log(z)**5/7^4 + 20*pow_im*pow_re**3*log(z)**4/7^3 + 15*pow_im*pow_re**2*log(z)**3/7^2 + 6*pow_im*pow_re*log(z)**2/7 + pow_im*log(z) + pow_re**7*log(z)**7/7^7 + pow_re**6*log(z)**6/7^5 + 3*pow_re**5*log(z)**5/7^4 + 5*pow_re**4*log(z)**4/7^3 + 5*pow_re**3*log(z)**3/7^2 + 3*pow_re**2*log(z)**2/7 + pow_re*log(z) + 1

(1 + pow1*log(x)/n + pow2*log(x)/n)**(z/2)



(1 + pow_re*log(z)/n + pow_im*log(z)/n)**n * (1 + pow_re*log(z)/n + pow_im*log(x)/n)**(z/2)
(1 + pow_re*log(z)/n + pow_im*log(z)/n)**n * (1 + pow_re*log(z)/n + pow_im*log(x)/n)**(z*n/2*n)
(1 + pow_re*log(z)/n + pow_im*log(z)/n)**2*n * (1 + pow_re*log(z)/n + pow_im*log(x)/n)**(z/2*n)


(1 + (pow_re + pow_im)*log(z)/n1)**2*n1
substitute (pow_re + pow_im)*log(z)/n1 = x2/n2, 2*n1 = n2 + x2/2
           n2 = 2*n1 - x2/2
           n2 = n1*x2/((pow_re + pow_im)*log(z))
           2*n1 - x2/2 = n1*x2/((pow_re + pow_im)*log(z))
           4*n1 - x2 = 2*n1*x/((pow_re + pow_im)*log(z))
           ((pow_re + pow_im)*log(z)) = 2*n1*x/(4*n1 - x2)
           ((pow_re + pow_im)*log(z)) = 2/(4/x2 - 1/n1)
           (4/x2 - 1/n1) = 2/((pow_re + pow_im)*log(z))
           1/n1 = 4/x2 - 2/((pow_re + pow_im)*log(z))
           n1 = 1 / (4/x2 - 2/((pow_re + pow_im)*log(z)))
           4/x2 = 2/((pow_re + pow_im)*log(z)) + 1/n1
           x2 = 4/(2/((pow_re + pow_im)*log(z)) + 1/n1)
            n2 = 2*n1 - x2/2
            n2 = 2 / (4/x - 2/((pow_re + pow_im)*log(z))) - 1/(1/((pow_re + pow_im)*log(z)) + 1/n1)
            n2 = 2 / ((2/((pow_re + pow_im)*log(z)) + 1/n1) - 2/((pow_re + pow_im)*log(z))) - 1/(1/((pow_re + pow_im)*log(z)) + 1/n1)
            x2/2 = 2*n1 - n2
            x2 = 4*n1 - 2*n2 
            
           n2 = 2*n1 - x2/2
           n2 = n1*x2/x1
           2*n1 - x2/2 = n1*x2/x1
           x2/2 = 2*n1 - n1*x2/x1
           x2 = 4*n1 - 2*n1*x2/x1
           x2 + 2*n1*x2/x1 = 4*n1
           x2*(x1 + 2*n1)/x1 = 4*n1
           x2 = 4*n1*x1/(x1 + 2*n1)
           x2 = 4*x1/(x1/n1 + 2)
           x2 = 2*x1

n2, n1, x2, x1, pow_re, pow_im, z = sympy.symbols("n1 n2 x2 x1 pow_re pow_im z")
sympy.simplify(sympy.expand("2 / ((2/((pow_re + pow_im)*log(z)) + 1/n1) - 2/((pow_re + pow_im)*log(z))) - 1/(1/((pow_re + pow_im)*log(z)) + 1/n1)"))
n2 = n1*(2*n1 + (pow_im + pow_re)*log(z))/(n1 + (pow_im + pow_re)*log(z))
x2 = 4*n1 - 2*n2
   = 4*n1 - 2*n1*(2*n1 + (pow_im + pow_re)*log(z))/(n1 + (pow_im + pow_re)*log(z))

(1 + (pow_re + pow_im)*log(z)/n1)**2*n1
x1 = (pow_re + pow_im)*log(z)
x1/n1 = x2/n2
2*n1 = n2 + x2/2

(1 + (pow_re + pow_im)*log(z)/n1)**2*n1
(1 + x1/n1)**2*n1
(1 + x2/n2)**(n2 + x2/2)
e^(x2) = e^(4*n1 - 2*n1*(2*n1 + (pow_im + pow_re)*log(z))/(n1 + (pow_im + pow_re)*log(z)))
       = e^(4*n1 - 2*n1*(2*n1 + x1)/(n1 + x1))
       = e^2*n1*(2 - (2*n1 + x1)/(n1 + x1))
       = e^2*n1*(2 - n1/(n1 + x1) - 1)
       = e^2*n1*(1 - n1/(n1 + x1))
       = e^2*n1*((n1 + x1 - n1)/(n1 + x1))
       = e^2*n1*(x1/(n1 + x1))
       = e^(2*x1/(1 + x1/n1))
       = e^(2*x1) as n1 -> inf
       = e^(2*(pow_im + pow_re)*log(z))
       = z^(2*(pow_im + pow_re))


e^2*n1*(2 - n1/(n1 + x1) - 1) = 0
2*n1*(2 - n1/(n1 + x1) - 1) = -inf
(2 - 1/(1 + x1/n1) - 1) = -inf/2*n1
1/(1 + x1/n1) = inf/2*n1 - 1
1/(1 + x1/n1) = (inf - 2*n1)/2*n1
(1 + x1/n1) = 2*n1/(inf - 2*n1)
x1/n1 = 2*n1/(inf - 2*n1) - 1
x1 = 2*n1^2/(inf - 2*n1) - 1
x1 = 2/(inf/n1^2 - 2/n1) - 1
x1 = -1
(pow_im + pow_re)*log(z) = -1
z^(pow_im + pow_re) = e^-1
log(z) = -1/(pow_im + pow_re)
z = -1/(pow_im + pow_re)
(pow_im + pow_re) = 1/z



(1 + (pow_re + pow_im)*log(z)/n)^(n + eps) = e^((pow_re + pow_im)*log(z))
x1 = (pow_re + pow_im)*log(z)
zpow = (pow_re + pow_im)
(1 + x1/n)^(n + eps) = z^zpow
(n + eps)*log(1 + x1/n) = zpow*log(z)
eps*log(1 + x1/n) = zpow*log(z) - n*log(1 + x1/n)
eps = (zpow*log(z) - n*log(1 + x1/n))/log(1 + x1/n)
eps = ((1/n)*zpow*log(z) - log(1 + x1/n))/((1/n)*log(1 + x1/n))

L'Hopital's Rule
x1, n, z = sympy.symbols("x1 n z")
sympy.Derivative("((1/n)*zpow*log(z) - log(1 + x1/n))", "n").doit() = x1/(n**2*(1 + x1/n)) - zpow*log(z)/n**2
sympy.Derivative("((1/n)*log(1 + x1/n))", "n").doit()               = -log(1 + x1/n)/n**2 - x1/(n**3*(1 + x1/n))

sympy.simplify(sympy.expand("(x1/(n**2*(1 + x1/n)) - zpow*log(z)/n**2) / (-log(1 + x1/n)/n**2 - x1/(n**3*(1 + x1/n)))"))

(-n*x1 + n*zpow*log(z) + x1*zpow*log(z))/(n*log((n + x1)/n) + x1*log((n + x1)/n) + x1)
(-n*x1 + n*zpow*log(z) + x1*zpow*log(z))/((n + x1)*log((n + x1)/n) + x1)

sympy.Derivative("(-n*x1 + n*zpow*log(z) + x1*zpow*log(z))", "n").doit() = -x1 + zpow*log(z)
sympy.Derivative("((n + x1)*log((n + x1)/n) + x1)", "n").doit()          = n*(1/n - (n + x1)/n**2) + log((n + x1)/n)

(-x1 + zpow*log(z)) / (n*(1/n - (n + x1)/n**2) + log((n + x1)/n))

sympy.Derivative("(-x1 + zpow*log(z))", "n").doit()                         = 0
sympy.Derivative("(n*(1/n - (n + x1)/n**2) + log((n + x1)/n))", "n").doit() = n*(-2/n**2 + 2*(n + x1)/n**3) + n*(1/n - (n + x1)/n**2)/(n + x1) + 1/n - (n + x1)/n**2

sympy.simplify(sympy.expand("n*(-2/n**2 + 2*(n + x1)/n**3) + n*(1/n - (n + x1)/n**2)/(n + x1) + 1/n - (n + x1)/n**2"))
0 / (x1**2/(n**2*(n + x1)))
0 / (x1**2/n**2)/(n + x1))
0 / (x1**2/n**3)/(1 + x1/n))
0

(1 + (pow_re + pow_im)*log(z)/n)^(n + eps) = e^((pow_re + pow_im)*log(z))
x1 = (pow_re + pow_im)*log(z)
(1 + x1/n)^(n + eps) = e^x1
(n + eps)*log(1 + x1/n) = x1
eps*log(1 + x1/n) = x1 - n*log(1 + x1/n)
eps = (x1 - n*log(1 + x1/n))/log(1 + x1/n)
eps = (x1/n - log(1 + x1/n))/((1/n)*log(1 + x1/n))

L'Hopital's Rule
x1, n = sympy.symbols("x1 n")
sympy.Derivative("x1/n - log(1 + x1/n)", "n").doit()   = -x1/n**2 + x1/(n**2*(1 + x1/n))
sympy.Derivative("(1/n) * log(1 + x1/n)", "n").doit() = -log(1 + x1/n)/n**2 - x1/(n**3*(1 + x1/n))

(-x1/n**2 + x1/(n**2*(1 + x1/n))) / (-log(1 + x1/n)/n**2 - x1/(n**3*(1 + x1/n)))
(-x1 + x1/(1 + x1/n)) / (-log(1 + x1/n) - x1/(n*(1 + x1/n)))

sympy.Derivative("(-x1 + x1/(1 + x1/n))", "n").doit()              = x1**2/(n**2*(1 + x1/n)**2)
sympy.Derivative("-log(1 + x1/n) - x1/(n*(1 + x1/n))", "n").doit() = 2*x1/(n**2*(1 + x1/n)) - x1**2/(n**3*(1 + x1/n)**2) 

sympy.simplify(sympy.expand("(x1^2/(n^2*(1 + x1/n)^2)) / (2*x1/(n^2*(1 + x1/n)) - x1^2/(n^3*(1 + x1/n)^2))")
n*x1/(2*n + x1)
x1/(2 + x1/n)
x1/2

(x1^2/(n^2*(1 + x1/n)^2)) / (2*x1/(n^2*(1 + x1/n)) - x1^2/(n^3*(1 + x1/n)^2))
(x1^2/n^2) / (2*x1*(1 + x1/n)/(n^2*) - x1^2/n^3))
(x1^2) / (2*x1*(1 + x1/n) - x1^2/n)
(x1^2) / (2*x1 + 2*x1^2/n - x1^2/n)
(x1^2) / (2*x1)
x1 / 2 = (pow_re + pow_im)*log(z)/2


(1 + pow_re*log(z)/n + pow_im*log(z)/n)**2*n
substitute 2*n = n + (pow_re + pow_im)*log(z)
             n = (1/2)*n + (1/2)*(pow_re + pow_im)*log(z)
(1 + (pow_re + pow_im)*log(z)/((1/2)*n/(pow_re + pow_im)*log(z) + (1/2)))**((1/2)*n + (1/2)*(pow_re + pow_im)*log(z))
(1 + 1/(n/(2*(pow_re + pow_im)*log(z)) + 1/2))**((1/2)*n + (1/2)*(pow_re + pow_im)*log(z))

(1 + (pow_re + pow_im)*log(z)/n)^(2*n)
substitute 2*n = n + 2*(pow_re + pow_im)*log(z)
             n = (1/2)*n + (pow_re + pow_im)*log(z)
(1 + (pow_re + pow_im)*log(z)/((1/2)*n + (pow_re + pow_im)*log(z)))^(n + 2*(pow_re + pow_im)*log(z))
(1 + 2*(pow_re + pow_im)*log(z)/(n + 2*(pow_re + pow_im)*log(z)))^(n + 2*(pow_re + pow_im)*log(z))
substitute x = 4*(pow_re + pow_im)*log(z)
           (1/2)*x = 2*(pow_re + pow_im)*log(z)
(1 + (1/2)*x/(n + (1/2)*x))^(n + (1/2)*x)
(1 + x/(2*n + x))^(n + (1/2)*x)
myexp_left = lambda x, n: mpmath.power(1 + mpmath.fdiv(x, 2*n + x), n + 0.5*x)


z_re, z_im, i, prec = 0, 0, 2, 192
myexp_left(mpmath.fmul(mpmath.mpc(z_re, z_im), mpmath.log(i)), prec)

myexp_left(mpmath.fmul(mpmath.mpc(-1, 1), mpmath.log(10)), prec)


class ms():
    def __init__(self, name, minsum, minsumidx, lenary, minsumary, minsumhsh, z_sum, icount):
        self.name = name
        self.maxminsum = 0
        self.maxminsumidx = -1
        self.minminsum = 10**8
        self.minminsumidx = -1
        self.lenary = 0
        self.minsumary = []
        self.minsumhsh = {}
        self.z_sum = mpmath.mpf(0)
        self.icount = 0
    
    def minsum_func(self, z_re, z_im):
        if self.lenary < 200 or mpmath.fabs(self.z_sum) < self.maxminsum:
            self.icount += 1
            if self.lenary < 200:
                abs_zsum = float(mpmath.fabs(self.z_sum))
                if abs_zsum in self.minsumhsh:
                    if type(self.minsumhsh[abs_sum]) is tuple:
                        self.minsumhsh[abs_sum] = [self.minsumhsh[abs_sum]]
                    if type(self.minsumhsh[abs_sum]) is list:
                        self.minsumhsh[abs_sum].append((self.z_sum, z_re, z_im))
                else:
                    self.minsumhsh[abs_zsum] = (self.z_sum, z_re, z_im)
                self.minsumary.append(self.z_sum)
                self.lenary = len(self.minsumary)
            else:
                self.minsumary.append(self.z_sum)
                if self.maxminsumidx == -1 or self.minminsumidx == -1:
                    self.maxminsum = mpmath.fabs(self.minsumary[0])
                    for msa in range(1, len(self.minsumary)):
                        abs_minsum = mpmath.fabs(self.minsumary[msa])
                        if abs_minsum > mpmath.fabs(self.maxminsum):
                            self.maxminsum = abs_minsum
                            self.maxminsumidx = msa
                        if abs_minsum < mpmath.fabs(self.minminsum):
                            self.minminsum = abs_minsum
                            self.minminsumidx = msa
                else:
                    if self.maxminsumidx != -1 and self.minsumary[self.maxminsumidx] in self.minsumary:
                        self.minsumary.remove(self.minsumary[self.maxminsumidx])
                    if float(self.mpmath.fabs(self.maxminsum)) in self.minsumhsh:
                        _ = self.minsumhsh.pop(float(mpmath.fabs(self.maxminsum)))
                    elif float(mpmath.fabs(self.maxminsum)) in self.minsumhsh:
                        _ = self.minsumhsh.pop(float(mpmath.fabs(self.maxminsum)))
                    elif mpmath.fabs(self.maxminsum) in self.minsumhsh:
                        _ = self.minsumhsh.pop(mpmath.fabs(self.maxminsum))
                    self.maxminsum = mpmath.fabs(self.minsumary[0])
                    for msa in range(1, len(self.minsumary)):
                        abs_minsum = mpmath.fabs(self.minsumary[msa])
                        if abs_minsum > mpmath.fabs(self.maxminsum):
                            self.maxminsum = abs_minsum
                            self.maxminsumidx = msa
                        if abs_minsum < mpmath.fabs(self.minminsum):
                            self.minminsum = abs_minsum
                            self.minminsumidx = msa
                abs_zsum = float(mpmath.fabs(self.z_sum))
                if abs_zsum in self.minsumhsh:
                    if type(self.minsumhsh[abs_sum]) is tuple:
                        self.minsumhsh[abs_sum] = [self.minsumhsh[abs_sum]]
                    if type(self.minsumhsh[abs_sum]) is list:
                        self.minsumhsh[abs_sum].append((self.z_sum, z_re, z_im))
                else:
                    self.minsumhsh[abs_zsum] = (self.z_sum, z_re, z_im)
                if self.icount > 1000:
                    print("new minsum" + self.name + " (" + round(mpmath.fabs(self.z_sum), 8) + ") found at coords (" + str(z_re) + ", " + str(z_im) + ")")




ms_e = ms("_e", 10**8, -1, 0, [], {}, 0, 0)
ms_mye1 = ms("_mye1", 10**8, -1, 0, [], {}, 0, 0)
ms_mye2 = ms("_mye2", 10**8, -1, 0, [], {}, 0, 0)
ms_mye3 = ms("_mye3", 10**8, -1, 0, [], {}, 0, 0)
ms_mye4 = ms("_mye4", 10**8, -1, 0, [], {}, 0, 0)
ms_mye5 = ms("_mye5", 10**8, -1, 0, [], {}, 0, 0)
ms_mye6 = ms("_mye6", 10**8, -1, 0, [], {}, 0, 0)
ms_intpow = ms("_intpow", 10**8, -1, 0, [], {}, 0, 0)
best_n = lambda iprec: int(mpmath.ceil(mpmath.exp(mpmath.log(iprec)/1.181)))
myexp_left1 = lambda x, n: mpmath.power(1 + mpmath.fdiv(x, 2*n + x), n + 0.5*x)
myexp_left2 = lambda x, n: mpmath.power(1 + mpmath.fdiv(x, n + 0.5*x), n + 0.5*x)
# prec_n = best_n(53)
prec_n = 6.20128516868674e+187
mpmath.mp.prec = 512
# tgt = abs(mpmath.exp(mpmath.fmul(2 * z_mpc, mpmath.log(17))))
this_myexp, prev_myexp, decreasing_myexp, min_myexp = 2**32, 2**32, [2, 2**32], [2, 2**32] 
for prec_n in [mpmath.power(2, ipow2) for ipow2 in range(64, 8192*8192 + 1, 64)]:
    this_myexp = abs(myexp_left(mpmath.fmul(mpmath.zetazero(8), mpmath.log(17)), prec_n))
    if this_myexp < prev_myexp and this_myexp < decreasing_myexp[1]:
        decreasing_myexp = [prec_n, this_myexp]
    if this_myexp < min_myexp[1]:
        min_myexp = [prec_n, this_myexp]
    prev_myexp = this_myexp
for z_re in [x/350 for x in range(-350, 350 + 1)]:
    for z_im in [x/350 for x in range(14*350, 22*350 + 1)]:
        for obj in [ms_e, ms_mye1, ms_mye2, ms_mye3, ms_mye4, ms_mye5, ms_mye6, ms_intpow]:
            obj.z_sum = mpmath.mpf(0)
        z_mpc = -mpmath.mpc(z_re, z_im)
        for i in range(1, 5000 + 1):
            ms_e.z_sum = mpmath.fadd(ms_e.z_sum, (-1)**((i + 1) % 2) * mpmath.exp(mpmath.fmul(2 * z_mpc, mpmath.log(i))))
            ms_mye1.z_sum = mpmath.fadd(ms_mye1.z_sum, (-1)**((i + 1) % 2) * myexp_left1(mpmath.fmul(0.5*z_mpc, mpmath.log(i)), prec_n))
            ms_mye2.z_sum = mpmath.fadd(ms_mye2.z_sum, (-1)**((i + 1) % 2) * myexp_left1(mpmath.fmul(z_mpc, mpmath.log(i)), prec_n))
            ms_mye3.z_sum = mpmath.fadd(ms_mye3.z_sum, (-1)**((i + 1) % 2) * myexp_left1(mpmath.fmul(2*z_mpc, mpmath.log(i)), prec_n))
            ms_mye4.z_sum = mpmath.fadd(ms_mye4.z_sum, (-1)**((i + 1) % 2) * myexp_left2(mpmath.fmul(0.5*z_mpc, mpmath.log(i)), prec_n))
            ms_mye5.z_sum = mpmath.fadd(ms_mye5.z_sum, (-1)**((i + 1) % 2) * myexp_left2(mpmath.fmul(z_mpc, mpmath.log(i)), prec_n))
            ms_mye6.z_sum = mpmath.fadd(ms_mye6.z_sum, (-1)**((i + 1) % 2) * myexp_left2(mpmath.fmul(2*z_mpc, mpmath.log(i)), prec_n))
            ms_intpow.z_sum = mpmath.fadd(ms_intpow.z_sum, (-1)**((i + 1) % 2) * mpmath.power(i, 2 * z_mpc))
        for obj in [ms_e, ms_mye1, ms_mye2, ms_mye3, ms_mye4, ms_mye5, ms_mye6, ms_intpow]:
            obj.minsum_func(z_re, z_im)

for obj in [ms_e, ms_mye, ms_intpow]:
    min_sum = min([abs(z_sum) for z_sum in obj.minsumary])
    if type(obj.minsumhsh[float(mpmath.fabs(min_sum))]) is tuple:
        print("ms" + obj.name + ", " + str(obj.minsumhsh[float(mpmath.fabs(min_sum))]))
    elif type(obj.minsumhsh[float(mpmath.fabs(min_sum))]) is list:
        for msh in range(0, len(obj.minsumhsh[float(mpmath.fabs(min_sum))])):
            print("ms" + obj.name + ", " + str(obj.minsumhsh[float(mpmath.fabs(min_sum))][msh]))

ms_e, (mpf('0.0'), 0.5, 14)
ms_mye, (mpc(real='0.0', imag='0.0'), -0.9266666666666666, 0.0)
ms_intpow, (mpc(real='-106027.69717883406', imag='147553.75407192047'), -0.9266666666666666, 3.7066666666666666)


(1 + (pow_re + pow_im)*log(z)/n)^(2*n1)
substitute 2*n1 = n2 + (1/2)*(pow_re + pow_im)*log(z)
(1 + (pow_re + pow_im)*log(z)/(n2 + (1/2)*(pow_re + pow_im)*log(z)))^(n2 + (1/2)*(pow_re + pow_im)*log(z))
(1 + (pow_re + pow_im)*log(z)/(n2 + (1/2)*(pow_re + pow_im)*log(z)))^(n2 + (1/2)*(pow_re + pow_im)*log(z))
substitute (pow_re + pow_im)*log(z)/(n2 + (1/2)*(pow_re + pow_im)*log(z)) = (pow_re + pow_im)*log(z) / n2
           n2 = n2 + (1/2)*(pow_re + pow_im)*log(z))
           (1/2)*(pow_re + pow_im)*log(z)) = 0


def calc_zeta_sum(z_re, z_im, max_i, prec):
    best_n = lambda iprec: int(mpmath.ceil(mpmath.exp(mpmath.log(iprec)/1.181)))
    myexp_left = lambda x, n: mpmath.power(1 + mpmath.fdiv(x, n + 0.5*x), n + 0.5*x)
    hsh = {}
    hsh[53] = 10**6
    hsh[64] = 5 * 10**5
    hsh[128] = 2.5 * 10**5
    hsh[256] = 2 * 10**5
    if prec not in hsh:
        return -1
    n = best_n(prec)
    z_sum_e = mpmath.mpf(0)
    z_sum_mye = mpmath.mpf(0)
    z_sum_intpow = mpmath.mpf(0)
    z_mpc = -mpmath.mpc(z_re, z_im)
    t1 = time.time()
    for i in range(1, max_i + 1):
        # alternating sum
        z_sum_e = mpmath.fadd(z_sum_e, (-1)**((i + 1) % 2) * mpmath.exp(mpmath.fmul(2 * z_mpc, mpmath.log(i))))
        z_sum_mye = mpmath.fadd(z_sum_mye, (-1)**((i + 1) % 2) * myexp_left(mpmath.fmul(z_mpc, mpmath.log(i)), n))
        z_sum_intpow = mpmath.fadd(z_sum_intpow, (-1)**((i + 1) % 2) * mpmath.power(i, 2 * z_mpc))
        if  i % hsh[prec] == 0:
            t2 = time.time()
            print(str(i) + ", time elapsed " + str(round((t2 - t1)/60, 2)) + " minutes")
            print("z_sum_e = mpc('" + str(z_sum_e.real) + "', '" + str(z_sum_e.imag) + "')")
            print("abs(z_sum_e) = mpf('" + str(mpmath.fabs(z_sum_e)) + "')")
            print("z_sum_mye = mpc('" + str(z_sum_mye.real) + "', '" + str(z_sum_mye.imag) + "')")
            print("abs(z_sum_mye) = mpf('" + str(mpmath.fabs(z_sum_mye)) + "')")
            print("z_sum_intpow = mpc('" + str(z_sum_intpow.real) + "', '" + str(z_sum_intpow.imag) + "')")
            print("abs(z_sum_intpow) = mpf('" + str(mpmath.fabs(z_sum_intpow)) + "')")
    return z_sum_e, z_sum_mye, z_sum_intpow


e^0.5+14j 0
e^2(0.25+7j) = 0

mpmath.mp.prec, maxi = 53, 8*10**6
z_sum_e, z_sum_mye, z_sum_intpow = calc_zeta_sum(0.25, mpmath.zetazero(8).imag/2, maxi, 53)
mpc(real='113003.53473550486', imag='1037850.5789680264')
mpf('1043984.4937196079')

 
def calc_and_print_left(i, z_re, z_im, prec):
    x = mpmath.fmul(4*mpmath.log(i), mpmath.mpc(z_re, z_im))
    z_left = myexp_left(x, mpmath.power(2, best_n(prec) + 0.5*x))
    print("mpmath.mpc('" + str(z_left.real) + "', '" + str(z_left.imag) + "')")
    if z_left.real < 1:
        print("mpmath.mpc(1 - mpmath.power(2, mpmath.mpf('" + str(mpmath.log(1 - z_left.real, 2)) + "')), mpmath.power(2, mpmath.mpf('" + str(mpmath.log(z_left.imag, 2)) + "')))")
    else:
        print("mpmath.mpc(1 + mpmath.power(2, mpmath.mpf('" + str(mpmath.log(z_left.real - 1, 2)) + "')), mpmath.power(2, mpmath.mpf('" + str(mpmath.log(z_left.imag, 2)) + "')))")

calc_and_print_left(2, 0.5, mpmath.zetazero(8).imag, 128)
mpmath.mpc('-1.861880575089820214368697096249056656603618683596715898181384172657013964783', '-0.7303428811888274281234803971029273831100015791050236645751985546096548344079')

calc_and_print_left(200, 0.5, mpmath.zetazero(8).imag, 256)
mpmath.mpc('180.2073747218817283887521962999749743214426947907167745374743469163731142479', '86.748499098527936755092713669061064154740168376557518224639687492230540879')

(1 + pow_re*log(z)/n + pow_im*log(x)/n)**(z/2*n)
myexp_right = lambda z, n: mpmath.power(1 + mpmath.fdiv(z, n), mpmath.fdiv(z, 2*n))
(1 + pow_re*log(z)/n + pow_im*log(z)/n)**2*n
myexp_left = lambda z, n: mpmath.power(1 + mpmath.fdiv(z, n), 2*n)

best_n = lambda iprec: int(mpmath.ceil(mpmath.exp(mpmath.log(iprec)/1.181)))
mpmath.mp.prec = 256
def calc_and_print_right(x, z_re, z_im, prec):
    z_right = myexp_right(mpmath.fmul(mpmath.log(x), mpmath.mpc(z_re, z_im)), mpmath.power(2, best_n(prec)))
    print("mpmath.mpc('" + str(z_right.real) + "', '" + str(z_right.imag) + "')")
    if z_right.real < 1:
        print("mpmath.mpc(1 - mpmath.power(2, mpmath.mpf('" + str(mpmath.log(1 - z_right.real, 2)) + "')), mpmath.power(2, mpmath.mpf('" + str(mpmath.log(z_right.imag, 2)) + "')))")
    else:
        print("mpmath.mpc(1 + mpmath.power(2, mpmath.mpf('" + str(mpmath.log(z_right.real - 1, 2)) + "')), mpmath.power(2, mpmath.mpf('" + str(mpmath.log(z_right.imag, 2)) + "')))")

def calc_and_print_left(x, z_re, z_im, prec):
    z_left = myexp_left(mpmath.fmul(mpmath.log(x), mpmath.mpc(z_re, z_im)), mpmath.power(2, best_n(prec)))
    print("mpmath.mpc('" + str(z_left.real) + "', '" + str(z_left.imag) + "')")
    if z_left.real < 1:
        print("mpmath.mpc(1 - mpmath.power(2, mpmath.mpf('" + str(mpmath.log(1 - z_left.real, 2)) + "')), mpmath.power(2, mpmath.mpf('" + str(mpmath.log(z_left.imag, 2)) + "')))")
    else:
        print("mpmath.mpc(1 + mpmath.power(2, mpmath.mpf('" + str(mpmath.log(z_left.real - 1, 2)) + "')), mpmath.power(2, mpmath.mpf('" + str(mpmath.log(z_left.imag, 2)) + "')))")

calc_and_print_right(2, 0.5, 99.2137, 128)
mpmath.mpc(real='0.9999999999999999999999999999999995552727740715542474719152646449392724777257708', imag='4.482632149839390380245506826541075924858248298394234182816508048982849972692813e-36')
mpmath.mpc(1 - mpmath.power(2, mpmath.mpf('-110.7926344978703334291269064837398435091292258356578542043298198469285330566')), mpmath.power(2, mpmath.mpf('-117.4250653009813070299737535741803945976984348903131225035278003479079638272')))

calc_and_print_right(2, 0.5, 99.2137, 256)
mpmath.mpc('1.000000000000000000000000000000000000011295396073927752966531061612777794918', '0.0')
mpmath.mpc(1 + mpmath.power(2, mpmath.mpf('-126.0575327458897952286034157768061800737602870017616646573981471785476248789')), mpmath.power(2, mpmath.mpf('-inf')))
~ mpmath.mpc(1, 0)

calc_and_print_right(200, 0.5, 99.2137, 128)
mpmath.mpc('1.000000000000000000000000000000000000659973472517589182802802586269155792294', '0.0')
mpmath.mpc(mpmath.power(2, mpmath.mpf('-120.1889314739923149303252294892831969576983361284845561589668052777469664199')) - 1, mpmath.power(2, mpmath.mpf('-inf')))

calc_and_print_right(200, 0.5, 99.2137, 256)
mpmath.mpc('1.000000000000000000000000000000000000659973472517589182802802586269155792294', '0.0')
mpmath.mpc(mpmath.power(2, mpmath.mpf('-120.1889314739923149303252294892831969576983361284845561589668052777469664199')) - 1, mpmath.power(2, mpmath.mpf('-inf')))

calc_and_print_left(2, 0.5, 99.2137, 128)
mpmath.mpc('1.54162101108875052331133727861861603474024873688927447226866341479069816441', '-1.27412898019380869256470191682281413114422511813845225087366576788842291473')

calc_and_print_left(200, 0.5, 99.2137, 128)
mpmath.mpc('-90.32695704606519726404614811701016616720242486141539031754687629772922349946', '178.4405806726930585108166126928068239312055537699696310261426939806270782815')
calc_and_print_left(200, 0.5, 99.2137, 256)
mpmath.mpc('-90.32695704605458859501338089659523647543685474126917097165368145000414019129', '178.4405806726715662380244749258092784959345737250859255204576650838729876764')


(1 + z/n)^(n + z/2) = e^z

e^z = (1 + z/n)^(n + z/2) = (1 + z/n)^n * (1 + z/n)^(z/2)

e^(ln(z)*(a+bi)) = (1 + (ln(z)*(a+bi))/n)^n * (1 + (ln(x)*(a+bi))/n)^(z/2)

myexp_left = lambda z, n: mpmath.power(1 + mpmath.fdiv(z, n), n)
myexp_right = lambda z, n: mpmath.power(1 + mpmath.fdiv(z, n), mpmath.fdiv(z, 2))
myexp = lambda z, zpow, n: mpmath.fmul(myexp_left(mpmath.fmul(z, zpow), n), myexp_right(mpmath.fmul(z, zpow), n))

best_n = lambda iprec: int(mpmath.ceil(mpmath.exp(mpmath.log(iprec)/1.181)))

def calc_and_print(z1, z1_pow, iprec):
    n = best_n(iprec)
    z2 = myexp(z1, z1_pow, mpmath.power(2, n) + mpmath.power(2, n/2))
    print("mpmath.mpc('" + str(z2.real) + "', '" + str(z2.imag) + "')")
    print("mpmath.mpc(" + ("-" if z2.real < 0 else "") + "mpmath.power(2, " + str(mpmath.log(abs(z2.real), 2)) + "), " + ("-" if z2.imag < 0 else "") + "mpmath.power(2, " + str(mpmath.log(abs(z2.imag), 2)) + "))")

calc_and_print(2, mpmath.mpc(0.5, mpmath.power(2, 128 - 4)), mpmath.power(2, best_n(128)))
z = myexp(2, mpmath.mpc(0.5, mpmath.power(2, mpmath.mp.prec - 1)), mpmath.power(2, best_n(128)))
mpmath.mpc(real='-4.4448301323572658046554472665886154327045e-116068303764065406596853161452211912363', imag='-3.4607970967024993485119349967510662118789e-116068303764065406596853161452211912362')
mpmath.mpc(-mpmath.power(2, -3.8557055919976946436902596239385613726e+38), -mpmath.power(2, -3.8557055919976946436902596239385613726e+38))

z = myexp(2, mpmath.mpc(0.5, mpmath.power(2, 128 - 4)), mpmath.power(2, best_n(128)))
mpmath.mpc('-7.8547810242086417746620800438277425331e-14508537970508175813795383743662754832', '-5.8859821071931134559524924160196735044e-14508537970508175813795383743662754832')
mpmath.mpc(mpmath.power(2, -48196319899971183029156900904635217693.0), mpmath.power(2, -48196319899971183029156900904635217694.0))

mpmath.mp.prec = 512
z = myexp(2, mpmath.mpc(0.5, mpmath.power(2, 128)), mpmath.power(2, best_n(128)))
mpmath.mpc('-1.03995659627849626827340048243265550061348698994028267337284627053022688457036611637074596519870049041971229537277933435440046036483233445670822619106592e-232136607528130813158277332809981371707', '-4.03282272470279596515058010369990276719239079046785687786097999006703341375233381274521910492038151527923209499927602844743014920936290435994172062378293e-232136607528130813158277332809981371708')
mpmath.mpc(-mpmath.power(2, -771141118399538928620359367219497824737.32358481483062916243908261997311286077549995636706109812353440271644156879828208622380838186619669995862894490286, -mpmath.power(2, -771141118399538928620359367219497824738.690246237912821085961983476951566562028246229888100903248144355269426013748756209965227354299241430544491334518784))

mpmath.mp.prec = 4096
two = mpmath.mpf(0)
for i in range(mpmath.mp.prec - 1, int(mpmath.mp.prec/4), -1):
    two += mpmath.power(2, i)

i = 1024
while mpmath.power(1 + mpmath.fdiv(mpmath.mpc(0, 2 * mpmath.pi()), two), two + mpmath.mpf('0.5' + ('0' * i) + '1')).imag - mpmath.power(1 + mpmath.fdiv(mpmath.mpc(0, 2 * mpmath.pi()), two), two).imag != 0:
    i += 1

mpmath.power(1 + mpmath.fdiv(mpmath.mpc(0, 2 * mpmath.pi()), two), two + mpmath.mpf('0.5' + ('0' * 1231) + '1')).imag - mpmath.power(1 + mpmath.fdiv(mpmath.mpc(0, 2 * mpmath.pi()), two), two).imag
mpmath.power(1 + mpmath.fdiv(mpmath.mpc(0, 2 * mpmath.pi()), two), two + mpmath.mpf('0.5' + ('0' * 1232) + '1')).imag - mpmath.power(1 + mpmath.fdiv(mpmath.mpc(0, 2 * mpmath.pi()), two), two).imag

ip = -mpmath.lambertw(-mpmath.log(0.5))/mpmath.log(0.5)
mpmath.log(mpmath.mpc(0.37038, ip), mpmath.zetazero(100))
mpmath.log(mpmath.mpc(0.37122, ip), mpmath.zetazero(101))

def factors(n):
    rslt = []
    for p in primesieve.primes(int(math.sqrt(n))):
        while n % p == 0:
            n /= p
            rslt.append(p)
        if n == 1:
            break
    if n != 1:
        rslt.append(int(n))
    return rslt


# 
# e^(ai + bj + ck) = cos(abs_v) + (sin(abs_v)/abs_v)*(ai + bj + ck)
# e^(a + bi + cj + dk) = e^a * (cos(abs_v) + (sin(abs_v)/abs_v)*(bi + cj + dk)
# 
def power3(a, b, c, pow):
    abs_z = mpmath.sqrt(mpmath.power(a, 2) + mpmath.power(b, 2) + mpmath.power(c, 2))
    sin_over_z = mpmath.sin(abs_z)/abs_z
    return mpmath.cos(abs_z), sin_over_z * a, sin_over_z * b, sin_over_z * c

# 
# e^(ai + bj + ck) = cos(abs_v) + (sin(abs_v)/abs_v)*(ai + bj + ck)
# e^(a + bi + cj + dk) = e^a * (cos(abs_v) + (sin(abs_v)/abs_v)*(bi + cj + dk))
# e^((pi/sqrt(2)) * i) + e^((pi/sqrt(2)) * j) = e^((pi/sqrt(3)) * i) + e^((pi/sqrt(3)) * j) + e^((pi/sqrt(3)) * k) = -1
# (1 + (pi * i)/(n * sqrt(2)) + (pi * j)/(n * sqrt(2)))^n = -1
# (1 + (pi * i)/(2 * sqrt(2)) + (pi * j)/(2 * sqrt(2)))^2 = 1 + 2*(pi*i)/(2*sqrt(2)) + 2*(pi*j)/(2*sqrt(2)) - 2*(pi^2)/8 + 2*(pi*i*j)/8 = 1 + (pi*i)/sqrt(2) + (pi*j)/sqrt(2) - (pi^2)/4 + (pi*i*j)/4
# (1 + (pi * i)/(2 * sqrt(2)) + (pi * j)/(2 * sqrt(2)))^4 = 1 + 4*(pi*i)/(2*sqrt(2)) + 4*(pi*j)/(2*sqrt(2)) - 2*(pi^4)/8 + 2*(pi*i*j)/8 = 1 + (pi*i)/sqrt(2) + (pi*j)/sqrt(2) - (pi^2)/4 + (pi*i*j)/4
# 
def power4(a, b, c, d, pow):
    abs_z = mpmath.sqrt(mpmath.power(b, 2) + mpmath.power(c, 2) + mpmath.power(d, 2))
    sin_over_z = mpmath.exp(a) * mpmath.sin(abs_z)/abs_z
    return mpmath.exp(a) * (mpmath.cos(abs_z)), sin_over_z * a, sin_over_z * b, sin_over_z * c


def get_e1(x, adj):
    x = abs(x)
    n = mpmath.mpf(2)
    dn = mpmath.mpf(2)
    cmp = 1
    if adj >= 0.125 and x > mpmath.power(1 + mpmath.fdiv(1, 2), 2 + adj):
        n = mpmath.mpf(1) + mpmath.power(2, -64)
        dn = mpmath.mpf(0.25)
        if adj >= 0.125 and x > mpmath.power(1 + mpmath.fdiv(1, n), n + adj):
            n = mpmath.mpf(1) - mpmath.power(2, -64)
            dn = -mpmath.mpf(0.25)
            if adj >= 0.125 and x > mpmath.power(1 + mpmath.fdiv(1, mpmath.power(2, -64)), mpmath.power(2, -64) + adj):
                return 2**32
    for pow2 in range(3, 64 + 1, 1):
        if x < mpmath.power(1 + mpmath.fdiv(1, mpmath.power(2, pow2)), mpmath.power(2, pow2) + adj):
            if adj >= 0.125:
                n = mpmath.power(2, pow2 - 1)
                dn = mpmath.power(2, pow2 - 2)
            else:
                n = mpmath.power(2, pow2 - 1)
                dn = mpmath.power(2, pow2 - 2)
                cmp = -1
                break
    iter = 0
    print("n is " + str(n))
    print("dn is " + str(dn))
    while (cmp == 1 and mpmath.power(1 + mpmath.fdiv(1, n), n + adj) > x) or (cmp == -1 and mpmath.power(1 + mpmath.fdiv(1, n), n + adj) < x):
        iter += 1
        n += dn
        if (cmp == 1 and mpmath.power(1 + mpmath.fdiv(1, n), n + adj) < x) or (cmp == -1 and mpmath.power(1 + mpmath.fdiv(1, n), n + adj) > x):
            n -= dn
            dn /= 2
            if dn < mpmath.power(2, -mpmath.mp.prec):
                break
        if iter > 10**4:
            break
    return n


def get_e2(x, adj):
    x = abs(x)
    n = mpmath.mpf(2)
    dn = mpmath.mpf(2)
    if x > mpmath.exp(-1):
        return mpmath.inf 
    elif x < mpmath.power(1 - mpmath.fdiv(1, 2), 2 + adj):
        n = mpmath.mpf(1.0001220703125)
        dn = mpmath.mpf(0.5)
    for pow2 in range(4, 64 + 1, 2):
        if x > mpmath.power(1 - mpmath.fdiv(1, mpmath.power(2, pow2)), mpmath.power(2, pow2) + adj):
            n = mpmath.power(2, pow2 - 2)
            dn = mpmath.power(2, pow2 - 3)
        else:
            break
    iter = 0
    while mpmath.power(1 - mpmath.fdiv(1, n), n + adj) < x:
        iter += 1
        n += dn
        if mpmath.power(1 - mpmath.fdiv(1, n), n + adj) > x:
            n -= dn
            dn /= 2
            if dn < mpmath.power(2, -mpmath.mp.prec):
                break
        if iter > 10**4:
            break
    return n



returns 1/e

def get_e4(x, adj=0):
    x = abs(x)
    n = mpmath.mpf(2)
    dn = mpmath.mpf(64)
    cmp = 1
    if x >= 0.5:
        return 1
    elif x > mpmath.fdiv(1, mpmath.power(1 + mpmath.fdiv(1, 2), 2 + adj)):
        n = mpmath.mpf(1.0625)
        dn = mpmath.mpf(0.125)
        cmp = -1
    elif x > mpmath.fdiv(1, mpmath.power(1 + mpmath.fdiv(1, 1.0001), 1.0001 + adj)):
        n = mpmath.mpf(1.0001)
        dn = mpmath.mpf(0.0016)
        cmp = -1
    elif x < mpmath.fdiv(1, mpmath.power(1 + mpmath.fdiv(1, 0.99999999), 0.99999999 + adj)):
        n = mpmath.mpf(0.99999999)
        dn = -mpmath.power(2, -10)
    elif x < 1/math.e:
        return math.inf
    iter = 0
    print("n " + str(n) + ", dn " + str(dn) + ", cmp " + str(cmp))
    compare = lambda val, x, posneg: True if (val > x and posneg > 0) or (val < x and posneg < 0) else False 
    while compare(mpmath.fdiv(1, mpmath.power(1 + mpmath.fdiv(1, n), n + adj)), x, cmp):
        iter += 1
        n += dn
        if not compare(mpmath.fdiv(1, mpmath.power(1 + mpmath.fdiv(1, n), n + adj)), x, cmp):
            n -= dn
            dn /= 2
            if dn < mpmath.power(2, -mpmath.mp.prec):
                break
        if iter > 4*mpmath.mp.prec or n < 0:
            print("possible non-convergence")
            break
    return n


def get_e5(x, adj):
    n = mpmath.mpf(2)
    dn = mpmath.mpf(2)
    pi = mpmath.mpc(0, mpmath.pi())
    pow2 = min(mpmath.mp.prec, 64)
    two = mpmath.power(2, -pow2)
    if adj == mpmath.mpc(0, mpmath.pi()/2):
        # mpmath.mpf('-0.041079238187590181587515379250572247269049')
        if x > mpmath.power(1 + mpmath.fdiv(pi, 1 + two), two + adj).real:
            return 1
        if x < mpmath.power(1 + mpmath.fdiv(pi, 2), 2 + adj).real:
            n = mpmath.mpf(1) + two
            dn = mpmath.mpf(0.5)
    else:
        if x > mpmath.power(1 + mpmath.fdiv(pi, 1 + two), two + adj).real:
            return 1
        f = mpmath.mpf('1.3476738473541767437418299360071350666057')
        if x == mpmath.power(1 + mpmath.fdiv(pi, f), f + adj).real:
            return f
        minval = mpmath.mpf('-2.32059738855693746160808907538830233492')
        for thisx in [mpmath.fdiv(i, 64) for i in range(2 * 64, 6 * 64)]:
            if mpmath.power(1 + mpmath.fdiv(pi, thisx), thisx + adj).real < minval:
                minval = mpmath.power(1 + mpmath.fdiv(pi, 2), 2 + adj).real
        if x < minval:
            return 0
        if x > mpmath.power(1 + mpmath.fdiv(pi, 2), 2 + adj).real:
            n = mpmath.mpf(1) + two
            dn = mpmath.mpf(0.5)
    for pow2 in range(4, 64 + 1, 2):
        if x < mpmath.power(1 + mpmath.fdiv(pi, mpmath.power(2, pow2)), mpmath.power(2, pow2) + adj).real:
            n = mpmath.power(2, pow2 - 2)
            dn = mpmath.power(2, pow2 - 3)
        else:
            break
    iter = 0
    two = mpmath.power(2, -mpmath.mp.prec)
    while mpmath.power(1 + mpmath.fdiv(pi, n), n + adj).real > x:
        iter += 1
        n += dn
        if mpmath.power(1 + mpmath.fdiv(pi, n), n + adj).real < x:
            n -= dn
            dn /= 2
            if dn < two:
                break
        if iter > 10**4:
            break
    return n


def get_e6(x, adj):
    x = abs(x)
    n = mpmath.mpf(2)
    dn = mpmath.mpf(2)
    pi = mpmath.mpc(0, mpmath.pi())
    if adj == mpmath.mpc(0, mpmath.pi()/2):
        if x > mpmath.power(1 - mpmath.fdiv(pi, 1.25), 1.25 + adj).real:
            return mpmath.inf
        if x < 1:
            n = 
    elif x > mpmath.power(1 - mpmath.fdiv(1, 2), 2 + adj).real:
        n = mpmath.mpf(1.0001220703125)
        dn = mpmath.mpf(0.5)
    for pow2 in range(4, 64 + 1, 2):
        if x > mpmath.power(1 - mpmath.fdiv(pi, mpmath.power(2, pow2)), mpmath.power(2, pow2) + adj).real:
            n = mpmath.power(2, pow2 - 2)
            dn = mpmath.power(2, pow2 - 3)
        else:
            break
    iter = 0
    while abs(mpmath.power(1 - mpmath.fdiv(1, n), n + adj).real) > x:
        iter += 1
        n += dn
        if mpmath.power(1 - mpmath.fdiv(1, n), n + adj).real > x:
            n -= dn
            dn /= 2
            if dn < mpmath.power(2, -mpmath.mp.prec):
                break
        if iter > 10**4:
            break
    return n




one = pyquaternion.Quaternion(1, 0, 0, 0)
i = pyquaternion.Quaternion(0, 1, 0, 0)
j = pyquaternion.Quaternion(0, 0, 1, 0)
k = pyquaternion.Quaternion(0, 0, 0, 1)
q = pyquaternion.Quaternion(1, numpy.pi, numpy.pi, numpy.pi)

pi = numpy.pi
n = 10**8
(1 + (pi*i)/n + (pi*j)/n + (pi*k)/n)**(n + 0.5 + pi*i/4 + pi*j/4 + pi*k/4)
Quaternion(0.43453756157654716, -0.5199927480368263, -0.5199927480368263, -0.5199927480368263)
(1 + (pi*i)/(n*numpy.sqrt(3)) + (pi*j)/(n*numpy.sqrt(3)) + (pi*k)/(n*numpy.sqrt(3)))**(n + 0.5 + pi*i + pi*j + pi*k)
Quaternion(-0.5111705101900349, 0.49622063436908853, 0.49622063436908853, 0.49622063436908853)

n  = 4000
(1 + (pi*i)/(n*numpy.sqrt(3)) + (pi*j)/(n*numpy.sqrt(3)) + (pi*k)/(n*numpy.sqrt(3)))**(n + pi*i/2 + pi*j/2 + pi*k/2)
Quaternion(-1.0012344614902897, 3.7364036643106084e-07, 3.7364036643106084e-07, 3.7364036643106084e-07)
(1 + (pi*i)/(n*numpy.sqrt(3)) + (pi*j)/(n*numpy.sqrt(3)) + (pi*k)/(n*numpy.sqrt(3)))**(n + pi*i/3 + pi*j/3 + pi*k/3)
Quaternion(-1.0012344614902897, 3.7364036643106084e-07, 3.7364036643106084e-07, 3.7364036643106084e-07)pyquaternion.Quaternion.log(1 + (pi*i)/n + (pi*j)/n + (pi*k)/n)/pyquaternion.Quaternion.log(pyquaternion.Quaternion(-1, 0, 0, 0))


n = 1000
q = pyquaternion.Quaternion(1, numpy.pi/n, numpy.pi/n, numpy.pi/n)
q**n
Quaternion(0.6661371314192844, -0.4306161985429402, -0.4306161985429402, -0.4306161985429402)
q = pyquaternion.Quaternion(1, numpy.pi/(n * numpy.sqrt(3)), numpy.pi/(n * numpy.sqrt(3)), numpy.pi/(n * numpy.sqrt(3)))
q**n
Quaternion(-1.0012344614902897, 3.7364036643106084e-07, 3.7364036643106084e-07, 3.7364036643106084e-07)
q**pyquaternion.Quaternion(n, pi*i/8, pi*j/8, pi*k/8)
Quaternion(3.2338250914366094e-07, 0.5777065176166859, 0.5777065176166859, 0.5777065176166859)
q**pyquaternion.Quaternion(n, 4*pi*i, 4*pi*j, 4*pi*k)
Quaternion(3.2338250914366094e-07, 0.5777065176166859, 0.5777065176166859, 0.5777065176166859)
n = 500
q = pyquaternion.Quaternion(1, numpy.pi/(n * numpy.sqrt(3)), numpy.pi/(n * numpy.sqrt(3)), numpy.pi/(n * numpy.sqrt(3)))
q**pyquaternion.Quaternion(n + 1, 4*pi*i, 4*pi*j, 4*pi*k)
Quaternion(-1.009918534293708, -0.003639473427506688, -0.003639473427506688, -0.003639473427506688)
q**pyquaternion.Quaternion(n + 1, 2*pi*i, 2*pi*j, 2*pi*k)
Quaternion(-1.009918534293708, -0.003639473427506688, -0.003639473427506688, -0.003639473427506688)
q**pyquaternion.Quaternion(n + 1, pi/3, pi/3, pi/3)
Quaternion(-1.009918534293708, -0.003639473427506688, -0.003639473427506688, -0.003639473427506688)




eps = (x/log(1 + x/n)) - n
(1 + x/n)^(n + eps) = e^x
(1 + x/n)^(n + (x/log(1 + x/n)) - n) = e^x
(1 + x/n)^(x/log(1 + x/n)) = e^x

eps = x/2
(1 + x/n)^(n + eps) = e^x
(1 + x/n)^(n + x/2) = e^x

(1 + ln(x)/n)^(n + ln(x)/2) = e^ln(x)
(n + ln(x)/2)*log(1 + ln(x)/n) = ln(x)
n*log(1 + ln(x)/n) = ln(x) - (ln(x)/2)*log(1 + ln(x)/n)
n*log(1 + ln(x)/n) = ln(x)*(1 - (1/2)*log(1 + ln(x)/n))
(1 + ln(x)/n)^n = e^ln(x)*(1 - (1/2)*log(1 + ln(x)/n))
(1 + ln(x)/n)^n = e^(ln(x) - (1/2)*ln(x)*log(1 + ln(x)/n))
(1 + ln(x)/n)^n = e^ln(x)/e^(ln(x)*(1/2)*log(1 + ln(x)/n))
(1 + ln(x)/n)^n = x/x^((1/2)*log(1 + ln(x)/n))

ln(x) = n*log(1 + ln(x)/n) / (1 - (1/2)*log(1 + ln(x)/n))
ln(x) = n / (1/log(1 + ln(x)/n) - 1/2)
ln(x) * (1/log(1 + ln(x)/n) - 1/2) = n
x = e^(n / (1/log(1 + ln(x)/n) - 1/2))
sqrt(x) = e^(1/2)*(n / (1/log(1 + ln(x)/n) - 1/2))

# p1p2 = e^61.535782837842311364741469541872681225432
# sqrt_p1p2 = e^30.767891418921155682370734770936
# 530457905397658442881753081
# p1 = e^29.972492502461657327448850611089
# p2 = e^31.563290335380654037292618930784

# find n such than log_p2/log_n - log_p1/log_n = 1
# log_n = log_p2 - log_p2
# n = mpmath.exp(mpmath.log(p2) - mpmath.log(p1)) 
# mpmath.mpf('4.9076628617729954155592273914703170395774')

# find n1 such than log_p2/log_n - log_sqrt_p1p2/log_n = 1
# find n2 such than log_sqrt_p1p2/log_n - log_sqrt_p1/log_n = 1
# log_n = log_p2 - log_sqrt_p1p2
# n = mpmath.exp(mpmath.log(p2) - mpmath.log(mpmath.sqrt(p1p2))) 
# mpmath.mpf('2.2153245499865240773770700530041473707343')
# log_n = log_sqrt_p1p2 - log_p1
# n = mpmath.exp(mpmath.log(mpmath.sqrt(p1p2)) - mpmath.log(p1)) 
# mpmath.mpf('2.2153245499865240773770700530041473707343')

# mpmath.log(p1p2, mpmath.mpf('4.9076628617729954155592273914703170395774'))
# mpf('38.682340121704018052645852708862764794826')
# mpmath.log(p1p2, mpmath.mpf('2.2153245499865240773770700530041473707343'))
# mpf('77.364680243408036105291705417725529590029')
# mpmath.log(p1p2, mpmath.mpf('2.2153245499865240773770700530041473707343')) / mpmath.log(p1p2, mpmath.mpf('4.9076628617729954155592273914703170395774'))
# mpf('2.0000000000000000000000000000000000000118')
# mpmath.mpf('4.9076628617729954155592273914703170395774') / mpmath.mpf('2.2153245499865240773770700530041473707343')
# mpf('2.215324549986524077377070053004147370746')

# mpmath.log(mpmath.log(p1p2) / mpmath.mpf('4.9076628617729954155592273914703170395774')) / mpmath.log(pi) = mpmath.mpf('2.215324549986524077377070053004147370746')
# mpmath.log(pi) = mpmath.log(mpmath.log(p1p2) / mpmath.mpf('4.9076628617729954155592273914703170395774')) / mpmath.mpf('2.215324549986524077377070053004147370746')
# pi = mpmath.exp(mpmath.log(mpmath.log(p1p2) / mpmath.mpf('4.9076628617729954155592273914703170395774')) / mpmath.mpf('2.215324549986524077377070053004147370746'))
# pi = mpmath.mpf('3.131501664191563910690803002383842072068')

e^pi*i = -1 = mpmath.power(1 + mpmath.fdiv(mpmath.mpc(0, pi), n), n + mpmath.mpc(0, pi)/2)
mpmath.mpc(0, p) = (n + mpmath.mpc(0, pi)/2)) * mpmath.log(1  + mpmath.fdiv(mpmath.mpc(0, pi), n)
n * mpmath.log(1  + mpmath.fdiv(mpmath.mpc(0, pi), n) = mpmath.mpc(0, pi) - (mpmath.mpc(0, pi)/2) * mpmath.log(1  + mpmath.fdiv(mpmath.mpc(0, pi), n)
n = mpmath.mpc(0, pi) * (1 - (1/2) * mpmath.log(1  + mpmath.fdiv(mpmath.mpc(0, pi), n)) / mpmath.log(1  + mpmath.fdiv(mpmath.mpc(0, pi), n)

pi = mpmath.mpf('3.131501664191563910690803002383842072068')

# 
# find_n(pi, 32, 128)
# find_n(pi, int(mpmath.mp.prec/2.6666), mpmath.mp.prec)
# 
def find_n(search_type, pi, min_pow2, iprec):
    savedprec = mpmath.mp.prec
    if iprec > mpmath.mp.prec:
        mpmath.mp.prec = iprec
    min_dist = mpmath.power(2, mpmath.mp.prec)
    min_n = 0
    dist_decreasing = False
    dist_decreasing_n1 = 0
    dist_decreasing_n2 = 0
    this_dist, prev_dist = 2**32, 2**32
    #imult = iprec/1.5
    imult = iprec*15/16
    max_pow2 = iprec*31/32
    for n1 in [mpmath.power(2, x/imult) for x in range(int(imult*min_pow2), int(imult*max_pow2))]:
        n2 = mpmath.mpc(0, pi) * (1 - (1/2) * mpmath.log(1  + mpmath.fdiv(mpmath.mpc(0, pi), n1))) / mpmath.log(1  + mpmath.fdiv(mpmath.mpc(0, pi), n1))
        this_dist = abs(n2 - n1)
        if this_dist < min_dist:
            dist_decreasing = True
            min_dist = this_dist
            min_n = n1
        else:
            dist_decreasing = False
            if dist_decreasing_n1 == 0:
                dist_decreasing_n1 = n1
        if (not dist_decreasing) and (this_dist > prev_dist) and (dist_decreasing_n2 == 0):
            dist_decreasing_n2 = n1
        prev_dist = this_dist
    if savedprec != mpmath.mp.prec:
        mpmath.mp.prec = savedprec
    return dist_decreasing_n1, dist_decreasing_n2, min_n



class arrayz:
    def __init__(self):
        self.log_p1_e_ary = []
        self.log_p1_p1p2_ary = []
        
        self.f1_hsh = {}
        self.f2_hsh = {}
        self.pi_hsh = {}
        self.log_pi_hsh = {}
        self.log_p1_e_hsh = {}
        self.log_p1_p1p2_hsh = {}
        self.log_min_n_hsh = {}
        self.log_dist_decr_n1_hsh = {}
        self.log_dist_decr_n2_hsh = {}
    
    def get_f1_sorted_log_p1_e(self):
        return [self.f1_hsh[x] for x in sorted(self.log_p1_e_ary)]
    
    def get_f1_sorted_log_p1_p1p2(self):
        return [self.f1_hsh[self.log_p1_e_hsh[x]] for x in sorted(self.log_p1_p1p2_ary)]
    
    def get_f2_sorted_log_p1_e(self):
        return [self.f2_hsh[x] for x in sorted(self.log_p1_e_ary)]
    
    def get_f2_sorted_log_p1_p1p2(self):
        return [self.f2_hsh[self.log_p1_e_hsh[x]] for x in sorted(self.log_p1_p1p2_ary)]
    
    def get_pi_sorted_log_p1_e(self):
        return [self.pi_hsh[x] for x in sorted(self.log_p1_e_ary)]
    
    def get_pi_sorted_log_p1_p1p2(self):
        return [self.pi_hsh[self.log_p1_e_hsh[x]] for x in sorted(self.log_p1_p1p2_ary)]
    
    def get_log_pi_sorted_log_p1_e(self):
        return [self.log_pi_hsh[x] for x in sorted(self.log_p1_e_ary)]
    
    def get_log_pi_sorted_log_p1_p1p2(self):
        return [self.log_pi_hsh[self.log_p1_e_hsh[x]] for x in sorted(self.log_p1_p1p2_ary)]
    
    def get_log_min_n_sorted_log_p1_e(self):
        return [self.log_min_n_hsh[x] for x in sorted(self.log_p1_e_ary)]
    
    def get_log_min_n_sorted_log_p1_p1p2(self):
        return [self.log_min_n_hsh[self.log_p1_e_hsh[x]] for x in sorted(self.log_p1_p1p2_ary)]
    
    def get_log_dist_decr_n1_sorted_log_p1_e(self):
        return [self.log_dist_decr_n1_hsh[x] for x in sorted(self.log_p1_e_ary)]
    
    def get_log_dist_decr_n1_sorted_log_p1_p1p2(self):
        return [self.log_dist_decr_n1_hsh[self.log_p1_e_hsh[x]] for x in sorted(self.log_p1_p1p2_ary)]
    
    def get_log_dist_decr_n2_sorted_log_p1_e(self):
        return [self.log_dist_decr_n2_hsh[x] for x in sorted(self.log_p1_e_ary)]
    
    def get_log_dist_decr_n2_sorted_log_p1_p1p2(self):
        return [self.log_dist_decr_n2_hsh[self.log_p1_e_hsh[x]] for x in sorted(self.log_p1_p1p2_ary)]




p1, p2 = 10396522617497, 51022627941473
p1, p2 = 14011402254263, 20852450975261
p1, p2 = 15053428029503, 66152457549107
p1p2 = mpmath.fmul(p1, p2)
sqrt_p1p2 = mpmath.sqrt(p1p2)
true_logp1_e = mpmath.log(p1)
true_logp1_p1p2 = mpmath.log(p1, p1p2)
true_f1 = mpmath.exp(mpmath.log(p2) - mpmath.log(p1))
true_f2 = mpmath.exp(mpmath.log(sqrt_p1p2) - mpmath.log(p1))
true_pi = mpmath.exp(mpmath.log(mpmath.log(p1p2) / true_f1) / true_f2)
true_logpi = mpmath.log(true_pi, mpmath.pi())
true_dist_decreasing_n1, true_dist_decreasing_n2, true_min_n = find_n(true_pi, int(mpmath.mp.prec/2.6666), 1.5 * mpmath.mp.prec)

idigits = 13
aryprimes = primesieve.primes(int(10**5.75 + 10**5 + 10**4.25))
olda = arrayz()
newa = arrayz()
pary = [p1, p2]
# len(aryprimes)
it = primesieve.Iterator()
const1 = 2*3*5*7 # 2310
const2 = 2*3*5*7*11*13*17*23 # 510510
# const2 = 2*3*5*7*11*13*17*23 # 11741730
for i in range(0, 127):
for i in range(0, 3):
    try:
        mpmath.mp.prec = 128
        newp1, newp2 = 2, 2
        bloop = True
        while bloop:
            newp1, newp2 = generate_primes(idigits)
            if newp1 > 10**(idigits - 1) and len(str(newp1)) >= idigits + 1 and newp1 not in pary and newp2 > 10**(idigits - 1) and len(str(newp2)) >= idigits + 1 and newp2 not in pary:
                bloop = False
                pary.append(newp1)
                pary.append(newp2)
        print(str(newp1) + ", " + str(newp2))
        thisary1 = [newp1, newp2]
        for thisp1 in thisary1:
            dir = 1 if thisp1 < sqrt_p1p2 else -1
            thisp2 = mpmath.floor(p1p2/thisp1 + const1*dir + const2*random.random()*dir)
            if mpmath.log(thisp2, 2) < 53:
                it.skipto(int(thisp2))
                thisp2 = it.next_prime()
            else:
                thisp2 = make_prime(thisp2, aryprimes, 30*dir, 1)
            newp1 = min(thisp1, thisp2)
            newp2 = max(thisp1, thisp2)
            newp1p2 = mpmath.fmul(newp1, newp2)
            
            f1_newp1_newp2 = mpmath.exp(mpmath.log(newp2) - mpmath.log(newp1))
            f2_p1p2_newp1 = mpmath.exp(mpmath.log(sqrt_p1p2) - mpmath.log(newp1))
            pi_p1p2_newp1_newp2 = mpmath.exp(mpmath.log(mpmath.log(p1p2) / f1_newp1_newp2) / f2_p1p2_newp1)
            #dist_decreasing_n1, dist_decreasing_n2, min_n = find_n(pi_p1p2_newp1_newp2, int(mpmath.mp.prec/2.6666), mpmath.mp.prec)
            dist_decreasing_n1, dist_decreasing_n2, min_n = find_n(pi_p1p2_newp1_newp2, int(mpmath.mp.prec/2.6666), 1.5 * mpmath.mp.prec)
            
            if float(mpmath.log(newp1)) not in olda.log_p1_e_ary and float(2 * mpmath.log(newp1, p1p2)) not in olda.log_p1_p1p2_ary:
                olda.log_p1_e_ary.append(float(mpmath.log(newp1)))
                olda.log_p1_p1p2_ary.append(float(2 * mpmath.log(newp1, p1p2)))
                olda.log_p1_e_hsh[olda.log_p1_p1p2_ary[-1]] = olda.log_p1_e_ary[-1] 
                olda.log_p1_p1p2_hsh[olda.log_p1_e_ary[-1]] = olda.log_p1_p1p2_ary[-1]
                
                olda.f1_hsh[olda.log_p1_e_ary[-1]] = f1_newp1_newp2
                olda.f2_hsh[olda.log_p1_e_ary[-1]] = f2_p1p2_newp1
                olda.pi_hsh[olda.log_p1_e_ary[-1]] = pi_p1p2_newp1_newp2
                olda.log_pi_hsh[olda.log_p1_e_ary[-1]] = mpmath.log(pi_p1p2_newp1_newp2, mpmath.pi())
                olda.log_min_n_hsh[olda.log_p1_e_ary[-1]] = mpmath.log(min_n, p1p2)
                olda.log_dist_decr_n1_hsh[olda.log_p1_e_ary[-1]] = mpmath.log(dist_decreasing_n1, p1p2)
                olda.log_dist_decr_n2_hsh[olda.log_p1_e_ary[-1]] = mpmath.log(dist_decreasing_n2, p1p2)
            else:
                print("")
                print("skipping found value " + str(float(mpmath.log(newp1))) + ", " + str(float(mpmath.log(newp1, p1p2))))
            
            print("")
            print(str(int(newp1)) + ", " + str(int(newp2)))
            print("pi_p1p2_newp1_newp2 " + str(pi_p1p2_newp1_newp2))
            print("min_n " + str(min_n) + " (2^" + str(float(mpmath.log(min_n, 2))) + ")")
            print("dist_decreasing_n1 " + str(dist_decreasing_n1) + " (2^" + str(float(mpmath.log(dist_decreasing_n1, 2))) + ")")
            print("dist_decreasing_n2 " + str(dist_decreasing_n2) + " (2^" + str(float(mpmath.log(dist_decreasing_n2, 2))) + ")")
            print("mpmath.log(min_n, p1p2) " + str(mpmath.log(min_n, p1p2)))
            print("mpmath.log(dist_decreasing_n1, p1p2) " + str(mpmath.log(dist_decreasing_n1, p1p2)))
            print("mpmath.log(dist_decreasing_n2, p1p2) " + str(mpmath.log(dist_decreasing_n2, p1p2)))
            
            f1_newp1_newp2 = mpmath.exp(mpmath.log(newp2) - mpmath.log(newp1))
            f2_newp1p2_newp1 = mpmath.exp(mpmath.log(mpmath.sqrt(newp1p2)) - mpmath.log(newp1))
            pi_newp1p2_newp1_newp2 = mpmath.exp(mpmath.log(mpmath.log(newp1p2) / f1_newp1_newp2) / f2_newp1p2_newp1)
            #dist_decreasing_n1, dist_decreasing_n2, min_n = find_n(pi_newp1p2_newp1_newp2, int(mpmath.mp.prec/2.6666), mpmath.mp.prec)
            dist_decreasing_n1, dist_decreasing_n2, min_n = find_n(pi_newp1p2_newp1_newp2, int(mpmath.mp.prec/2.6666), 1.5 * mpmath.mp.prec)
            
            if float(mpmath.log(newp1)) not in newa.log_p1_e_ary and float(2 * mpmath.log(newp1, newp1p2)) not in newa.log_p1_p1p2_ary:
                newa.log_p1_e_ary.append(float(mpmath.log(newp1)))
                newa.log_p1_p1p2_ary.append(float(2 * mpmath.log(newp1, newp1p2)))
                newa.log_p1_e_hsh[newa.log_p1_p1p2_ary[-1]] = newa.log_p1_e_ary[-1] 
                newa.log_p1_p1p2_hsh[newa.log_p1_e_ary[-1]] = newa.log_p1_p1p2_ary[-1]
                
                newa.f1_hsh[newa.log_p1_e_ary[-1]] = f1_newp1_newp2
                newa.f2_hsh[newa.log_p1_e_ary[-1]] = f2_newp1p2_newp1
                newa.pi_hsh[newa.log_p1_e_ary[-1]] = pi_newp1p2_newp1_newp2
                newa.log_pi_hsh[newa.log_p1_e_ary[-1]] = mpmath.log(pi_newp1p2_newp1_newp2, mpmath.pi())
                newa.log_min_n_hsh[newa.log_p1_e_ary[-1]] = mpmath.log(min_n, newp1p2)
                newa.log_dist_decr_n1_hsh[newa.log_p1_e_ary[-1]] = mpmath.log(dist_decreasing_n1, newp1p2)
                newa.log_dist_decr_n2_hsh[newa.log_p1_e_ary[-1]] = mpmath.log(dist_decreasing_n2, newp1p2)
            else:
                print("")
                print("skipping found value " + str(float(mpmath.log(newp1))) + ", " + str(float(mpmath.log(newp1, newp1p2))))
            
            print("")
            print(str(int(newp1)) + ", " + str(int(newp2)))
            print("pi_newp1p2_newp1_newp2 " + str(pi_newp1p2_newp1_newp2))
            print("min_n " + str(min_n) + " (2^" + str(float(mpmath.log(min_n, 2))) + ")")
            print("dist_decreasing_n1 " + str(dist_decreasing_n1) + " (2^" + str(float(mpmath.log(dist_decreasing_n1, 2))) + ")")
            print("dist_decreasing_n2 " + str(dist_decreasing_n2) + " (2^" + str(float(mpmath.log(dist_decreasing_n2, 2))) + ")")
            print("mpmath.log(min_n, newp1p2) " + str(mpmath.log(min_n, newp1p2)))
            print("mpmath.log(dist_decreasing_n1, newp1p2) " + str(mpmath.log(dist_decreasing_n1, newp1p2)))
            print("mpmath.log(dist_decreasing_n2, newp1p2) " + str(mpmath.log(dist_decreasing_n2, newp1p2)))
            
    except NameError as ne:
        print("NameError " + str(ne))
        break
    except AttributeError as ae:
        print("AttributeError " + str(ae))
        break
    except OverflowError as oe:
        print("OverflowError " + str(oe))
        pass
    except Exception as ex:
        print(str(type(ex)) + " " + str(ex))
        pass


plot_y = sorted([x for x in newa.log_pi_hsh.values()])
_ = plt.plot([x for x in range(0, len(plot_y))], plot_y)
_ = plt.hist([float(x) for x in newa.log_pi_hsh.values()], bins=30)
_ = plt.hist([float(x) for x in olda.log_pi_hsh.values()], bins=30)
plt.grid()
plt.show()

plot_x = sorted([olda.log_p1_e_ary[i] for i in range(0, len(olda.log_p1_e_ary)) if olda.log_pi_hsh[olda.log_p1_e_ary[i]] > 0.75 and olda.log_pi_hsh[olda.log_p1_e_ary[i]] < 1.25])
plot_y = [olda.log_pi_hsh[plot_x[i]] for i in range(0, len(plot_x))]
plot_x = sorted([olda.log_p1_e_ary[i] for i in range(0, len(olda.log_p1_e_ary)) if olda.log_pi_hsh[olda.log_p1_e_ary[i]] > 0.5 and olda.log_pi_hsh[olda.log_p1_e_ary[i]] < 1.5])
plot_y = [olda.log_pi_hsh[plot_x[i]] for i in range(0, len(plot_x))]
plot_x = sorted(olda.log_p1_e_ary)
plot_y = [olda.log_pi_hsh[plot_x[i]] for i in range(0, len(plot_x))]
_ = plt.plot(plot_x, plot_y)
plt.grid()
plt.show()

plot_x = sorted(newa.log_p1_e_ary)
plot_y = [newa.log_pi_hsh[plot_x[i]] for i in range(0, len(plot_x))]
_ = plt.plot(plot_x, plot_y)
plt.grid()
plt.show()

min(olda.log_p1_p1p2_ary)
0.960765059322892
float(true_logp1_p1p2)
0.4870742049620866
plot_x = sorted(olda.log_p1_p1p2_ary)
plot_y = [olda.log_dist_decr_n2_hsh[olda.log_p1_e_hsh[x]] for x in sorted(olda.log_p1_p1p2_ary)]
_ = plt.plot(plot_x, plot_y)
_ = plt.plot([true_logp1_p1p2, true_logp1_p1p2], [min(plot_y), max(plot_y)])
plt.grid()
plt.show()

plt.plot(olda.log_p1_e_ary, olda.log_min_n_ary)
plt.plot(olda.log_p1_p1p2_ary, olda.log_min_n_ary)
#plt.plot(newa.log_p1_e_ary, newa.log_min_n_ary)
plt.plot(newa.log_p1_p1p2_ary, newa.log_min_n_ary)
plt.grid()
plt.show()

plt.plot(olda.log_p1_e_ary, olda.log_dist_decr_n_ary)
plt.plot(olda.log_p1_p1p2_ary, olda.log_dist_decr_n_ary)
#plt.plot(newa.log_p1_e_ary, newa.log_dist_decr_n_ary)
plt.plot(newa.log_p1_p1p2_ary, newa.log_dist_decr_n_ary)
plt.grid()
plt.show()

plt.plot(olda.log_p1_e_ary, [mpmath.power(abs(olda.log_dist_decr_n_ary[i] - olda.log_min_n_ary[i]), 0.25) for i in range(0, len(olda.log_min_n_ary))])
plt.plot(olda.log_p1_p1p2_ary, [mpmath.power(abs(olda.log_dist_decr_n_ary[i] - olda.log_min_n_ary[i]), 0.25) for i in range(0, len(olda.log_min_n_ary))])
plt.grid()
plt.show()

plt.plot(olda.log_p1_p1p2_ary, olda.log_pi_ary)
plt.grid()
plt.show()


# min_n, dist_decreasing_n = find_n(mpmath.mpf('3.131501664191563910690803002383842072068'), 128)
# min_n
# mpf('1341683415130235180.1477260203434206913139')
# dist_decreasing_n
# mpf('36893488147419103232.0')
# mpmath.log(min_n, 2)
# mpf('60.21875')
# mpmath.log(dist_decreasing_n, 2)
# mpf('65.0')
# mpmath.log(min_n, p1p2)
# mpf('0.67831194882720033637933097687746845634305')
# mpmath.log(dist_decreasing_n, p1p2)
# mpf('0.73216857994840513734769508661397736854868')

# mpmath.log(mpmath.log(p1p2)/mpmath.mpf('4.9076628617729954155592273914703170395774'), mpmath.pi())
# mpf('2.2090984420997390122664479891647482136938')
# mpmath.log(mpmath.log(mpmath.log(p1p2)/mpmath.mpf('4.9076628617729954155592273914703170395774'), 2 * mpmath.pi()), 1 + mpmath.exp(-1))
# mpf('1.0187714125946917425422382777536103818282')
# mpmath.log(1/ (mpmath.log(mpmath.log(mpmath.log(p1p2)/mpmath.mpf('4.9076628617729954155592273914703170395774'), 2*mpmath.pi()), 1 + mpmath.exp(-1)) - 1))
# mpf('3.9754201731072248138491137621645187323209')
# mpmath.log(1/ (mpmath.log(mpmath.log(mpmath.log(p1p2)/mpmath.mpf('4.9076628617729954155592273914703170395774'), 2*mpmath.pi()), 1 + mpmath.exp(-1)) - 1), mpmath.pi())
# mpf('3.4728019441524637383956984713638197499845')
# mpmath.log(1/ (mpmath.log(mpmath.log(mpmath.log(p1p2)/mpmath.mpf('4.9076628617729954155592273914703170395774'), 2*mpmath.pi()), 1 + mpmath.exp(-1)) - 1), 2 * mpmath.pi())
# mpf('2.1630501004476814253448138755409720478312')

p1, p2 = 10396522617497, 51022627941473
x = mpmath.fmul(p1, p2)
n = mpmath.power(2, int(mpmath.mp.prec/2))
logx1 = mpmath.fdiv(n, mpmath.fdiv(1, mpmath.log(1 + mpmath.fdiv(mpmath.log(x), n))) - 0.5)
x1 = mpmath.exp(logx1)
logx2 = mpmath.log(x)
squaredx2 = mpmath.power(logx2/mpmath.pi(), 2)
fracx2 = fractions.Fraction(float(mpmath.fmod(squaredx2, 1))).limit_denominator(12)
squaredx2 = mpmath.floor(squaredx2 * fracx2.denominator) if mpmath.fmod(squaredx2 * fracx2.denominator, 1) < 0.5 else mpmath.ceil(squaredx2 * fracx2.denominator)
x2 = mpmath.exp(mpmath.sqrt(squaredx2/fracx2.denominator)*mpmath.pi())

x1/x
x2/x

m = e^(2^64 / (1/log(1 + ln(m)/2^64) - 1/2))
n = e^(2^64 / (1/log(1 + ln(n)/2^64) - 1/2))
m*n = e^(2^64 / (1/log(1 + ln(m*n)/2^64) - 1/2))
p1p2 = e^(2^64 / (1/log(1 + ln(p1p2)/2^64) - 1/2))

p1p2 % m = n
p1p2 % n = m

e^(2^64 / (1/log(1 + ln(p1p2)/2^64) - 1/2)) % e^(2^64 / (1/log(1 + ln(p1)/2^64) - 1/2)) = e^(2^64 / (1/log(1 + ln(p1p2/p1)/2^64) - 1/2))
e^(2^64 / (1/log(1 + ln(p1p2)/2^64) - 1/2)) % e^(2^64 / (1/log(1 + ln(p2)/2^64) - 1/2)) = e^(2^64 / (1/log(1 + ln(p1p2/p2)/2^64) - 1/2))


log(p1p2) = (2^64 / (1/log(1 + ln(p1)/2^64) - 1/2)) + (2^64 / (1/log(1 + ln(p2)/2^64) - 1/2))

(2^64 / (1/log(1 + ln(p1p2)/2^64) - 1/2)) = (2^64 / (1/log(1 + ln(p1)/2^64) - 1/2)) + (2^64 / (1/log(1 + ln(p1p2/p1)/2^64) - 1/2))
(1 / (1/log(1 + ln(p1p2)/2^64) - 1/2)) = (1 / (1/log(1 + ln(p1)/2^64) - 1/2)) + (1 / (1/log(1 + ln(p1p2/p1)/2^64) - 1/2))


(1 + x/n)^(n + eps) = e^x
(n + eps)*log(1 + x/n) = x
eps*log(1 + x/n) = x - n*log(1 + x/n)
eps = (x - n*log(1 + x/n))/log(1 + x/n)
eps = (x/n - log(1 + x/n))/((1/n) * log(1 + x/n))

# (x/n - log(1 + x/n)) / ((1/n) * log(1 + x/n))
myepsilon4 = lambda x, n: mpmath.fdiv(mpmath.fdiv(x, n) - mpmath.log(1 + mpmath.fdiv(x, n)), mpmath.fdiv(1, n) * mpmath.log(1 + mpmath.fdiv(x, n)))
eps = (x/log(1 + x/n)) - n
eps = x/2

L'Hopital's Rule
x, n = sympy.symbols("x n")
sympy.Derivative("x/n - log(1 + x/n)", "n").doit()   = -x/n**2 + x/(n**2*(1 + x/n))
sympy.Derivative("(1/n) * log(1 + x/n)", "n").doit() = -log(1 + x/n)/n**2 - x/(n**3*(1 + x/n))

(-x/n**2 + x/(n**2*(1 + x/n))) / (-log(1 + x/n)/n**2 - x/(n**3*(1 + x/n)))
(-x + x/(1 + x/n)) / (-log(1 + x/n) - x/(n*(1 + x/n)))
(-x + x/(1 + x/n)) / (-log(1 + x/n) - x/(n + x))

sympy.Derivative("-x + x/(1 + x/n)", "n").doit()          = x**2/(n**2*(1 + x/n)**2)
sympy.Derivative("-log(1 + x/n) - x/(n + x)", "n").doit() = x/(n + x)**2 + x/(n**2*(1 + x/n))

(x**2/(n**2*(1 + x/n)**2)) / (x/(n + x)**2 + x/(n**2*(1 + x/n)))
(x**2/(1 + x/n)**2) / (x*n**2/(n + x)**2 + x/(1 + x/n))
(x**2/(1 + x/n)) / (x*n**2*(1 + x/n)/(n + x)**2 + x)
(x**2/(1 + x/n)) / (x*n**2*(1 + x/n)/(n**2 + 2*x*n + x**2) + x)
(x**2/(1 + x/n)) / (x*(1 + x/n)/(1 + 2*x/n + x**2/n**2) + x)
x**2 / (x / 1 + x)
x**2 / (2*x)
x / 2



mypow = lambda x, n: mpmath.power(mpmath.fadd(1, mpmath.fdiv(x, n)), mpmath.fadd(n, mpmath.fdiv(x, 2)))

x**(a+bi) = e^(a*ln(x) + b*ln(x)i)
myintpow = lambda i, zpow, n: mypow(mpmath.mpc(zpow.real * mpmath.log(i), zpow.imag * mpmath.log(i)), n)

myintpow(2, mpmath.mpc(0.5, 14), mpmath.power(2, mpmath.mp.prec - 16))
mpmath.power(2, mpmath.mpc(0.5, 14))


arymindist = []
maxprec = 8192
maxminintpow2, maxminirrpow2 = 0, 0
minminintpow2, minminirrpow2 = maxprec, maxprec
maxlogminintpow2, maxlogminirrpow2 = 0, 0
minlogminintpow2, minlogminirrpow2 = maxprec, maxprec
for iprec in [128, 256, 512, 1024, 2048, 4096]:
    for i in [int(2**(2 + f/2.9)) for f in range(0, int(iprec/2) + 1, int(iprec/2/5))]:
        mpmath.mp.prec = iprec
        minintdist, minintpow2 = 1, 2
        minirrdist, minirrpow2 = 1, 2
        imult = 1024
        for pow2 in [x/imult for x in range(imult*2, imult*mpmath.mp.prec)]:
            z1 = myintpow(i, mpmath.mpc(0.5, 14), mpmath.power(2, pow2))
            z2 = mpmath.power(i, mpmath.mpc(0.5, 14))
            if mpmath.fabs(z1 - z2) < minintdist:
                minintdist = mpmath.fabs(z1 - z2)
                minintpow2 = pow2
            z1 = myintpow(i, mpmath.mpc(mpmath.power(0.5, mpmath.fdiv(1, 3)), 4 * mpmath.pi()), mpmath.power(2, pow2))
            z2 = mpmath.power(i, mpmath.mpc(mpmath.power(0.5, mpmath.fdiv(1, 3)), 4 * mpmath.pi()))
            if mpmath.fabs(z1 - z2) < minirrdist:
                minirrdist = mpmath.fabs(z1 - z2)
                minirrpow2 = pow2
        mpmath.mp.prec = 64
        if iprec/minintpow2 < minminintpow2:
            minminintpow2 = iprec/minintpow2
        if iprec/minirrpow2 < minminirrpow2:
            minminirrpow2 = iprec/minirrpow2
        if iprec/minintpow2 > maxminintpow2:
            maxminintpow2 = iprec/minintpow2
        if iprec/minirrpow2 > maxminirrpow2:
            maxminirrpow2 = iprec/minirrpow2
        log_iprec = mpmath.log(iprec)
        if log_iprec/mpmath.log(minintpow2) < minlogminintpow2:
            minlogminintpow2 = log_iprec/mpmath.log(minintpow2)
        if log_iprec/mpmath.log(minirrpow2) < minlogminirrpow2:
            minlogminirrpow2 = log_iprec/mpmath.log(minirrpow2)
        if log_iprec/mpmath.log(minintpow2) > maxlogminintpow2:
            maxlogminintpow2 = log_iprec/mpmath.log(minintpow2)
        if log_iprec/mpmath.log(minirrpow2) > maxlogminirrpow2:
            maxlogminirrpow2 = log_iprec/mpmath.log(minirrpow2)
        arymindist.append((iprec, i, minintdist, minirrdist, mpmath.log(minintdist, 2), mpmath.log(minirrdist, 2), minintpow2, minirrpow2))
        str_i = str(int(i)) + " (2^" + str(round(float(mpmath.log(i, 2)), 6)) + ")"
        print(str_i + ", minintdist mpf('" + str(minintdist) + "') = mpmath.power(2, mpmath.mpf('" + str(mpmath.log(minintdist, 2)) + "'))")
        print(str_i + ", minirrdist mpf('" + str(minirrdist) + "') = mpmath.power(2, mpmath.mpf('" + str(mpmath.log(minirrdist, 2)) + "'))")
        paren1 = "(" + str(iprec) + "/" + str(round(iprec/minintpow2, 6)) + " or exp(log(" + str(iprec) + ")/" + str(round(mpmath.log(iprec)/mpmath.log(minintpow2), 6)) + ")"
        paren2 = "(" + str(iprec) + "/" + str(round(iprec/minirrpow2, 6)) + " or exp(log(" + str(iprec) + ")/" + str(round(mpmath.log(iprec)/mpmath.log(minirrpow2), 6)) + ")"
        print(str_i + ", minintpow2 " + str(minintpow2) + " " + paren1 + ", minirrpow2 " + str(minirrpow2) + " " + paren2 + ", precision " + str(iprec))

def print_fractions():
    minintfrac = fractions.Fraction(float(1/minminintpow2)).limit_denominator(maxprec)
    minirrfrac = fractions.Fraction(float(1/minminirrpow2)).limit_denominator(maxprec)
    maxintfrac = fractions.Fraction(float(1/maxminintpow2)).limit_denominator(maxprec)
    maxirrfrac = fractions.Fraction(float(1/maxminirrpow2)).limit_denominator(maxprec)
    minlogintfrac = fractions.Fraction(float(1/minlogminintpow2)).limit_denominator(maxprec)
    minlogirrfrac = fractions.Fraction(float(1/minlogminirrpow2)).limit_denominator(maxprec)
    maxlogintfrac = fractions.Fraction(float(1/maxlogminintpow2)).limit_denominator(maxprec)
    maxlogirrfrac = fractions.Fraction(float(1/maxlogminirrpow2)).limit_denominator(maxprec)
    s = ""
    for sfrac in ["minintfrac", "minirrfrac", "maxintfrac", "maxirrfrac", "minlogintfrac", "minlogirrfrac", "maxlogintfrac", "maxlogirrfrac"]:
        s += sfrac + " " + str(eval(sfrac + ".numerator")) + "/" + str(eval(sfrac + ".denominator")) + "\n"
    print(s)



# 
# 
# 2048/2.937184 or exp(log(2048)/1.164568)
# 128/2.308418 or exp(log(128)/1.208335)
# 
# 

4 (2^2.0), minintdist mpf('6.5398808571072116e-27') = mpmath.power(2, mpmath.mpf('-86.9827942088694137'))
4 (2^2.0), minirrdist mpf('2.03305020043455506e-27') = mpmath.power(2, mpmath.mpf('-88.6684127230556148'))
4 (2^2.0), minintpow2 49.4013671875 (128/2.591021 or exp(log(128)/1.244117), minirrpow2 49.734375 (128/2.573673 or exp(log(128)/1.241978), precision 128
70 (2^6.129283), minintdist mpf('2.72490512710450974e-26') = mpmath.power(2, mpmath.mpf('-84.923924466553804'))
70 (2^6.129283), minirrdist mpf('2.52702191114166302e-25') = mpmath.power(2, mpmath.mpf('-81.7107641986182795'))
70 (2^6.129283), minintpow2 52.1435546875 (128/2.454762 or exp(log(128)/1.227119), minirrpow2 53.8427734375 (128/2.377292 or exp(log(128)/1.217247), precision 128
1239 (2^10.27496), minintdist mpf('4.82057747245047174e-25') = mpmath.power(2, mpmath.mpf('-80.7789963903060636'))
1239 (2^10.27496), minirrdist mpf('3.56601989515870698e-24') = mpmath.power(2, mpmath.mpf('-77.8919595253806935'))
1239 (2^10.27496), minintpow2 51.48046875 (128/2.48638 or exp(log(128)/1.231104), minirrpow2 52.2001953125 (128/2.452098 or exp(log(128)/1.226782), precision 128
21826 (2^14.41376), minintdist mpf('1.46555141379509864e-24') = mpmath.power(2, mpmath.mpf('-79.1748306964230254'))
21826 (2^14.41376), minirrdist mpf('2.97604768392533431e-23') = mpmath.power(2, mpmath.mpf('-74.8309485400993158'))
21826 (2^14.41376), minintpow2 54.431640625 (128/2.351573 or exp(log(128)/1.213935), minirrpow2 51.974609375 (128/2.462741 or exp(log(128)/1.228127), precision 128
384260 (2^18.551723), minintdist mpf('1.92581711556490518e-23') = mpmath.power(2, mpmath.mpf('-75.4588754776678405'))
384260 (2^18.551723), minirrdist mpf('6.37342985608313831e-22') = mpmath.power(2, mpmath.mpf('-70.4103481208993409'))
384260 (2^18.551723), minintpow2 52.5576171875 (128/2.435422 or exp(log(128)/1.224669), minirrpow2 51.771484375 (128/2.472404 or exp(log(128)/1.229346), precision 128
6764984 (2^22.689655), minintdist mpf('2.5558519499368543e-23') = mpmath.power(2, mpmath.mpf('-75.0505419131346042'))
6764984 (2^22.689655), minirrdist mpf('2.52924989290549234e-21') = mpmath.power(2, mpmath.mpf('-68.4217804086010125'))
6764984 (2^22.689655), minintpow2 55.44921875 (128/2.308418 or exp(log(128)/1.208335), minirrpow2 58.79296875 (128/2.177131 or exp(log(128)/1.190968), precision 128

4 (2^2.0), minintdist mpf('9.78975109555719596e-53') = mpmath.power(2, mpmath.mpf('-172.77091684925948'))
4 (2^2.0), minirrdist mpf('6.83293437332407586e-53') = mpmath.power(2, mpmath.mpf('-173.289683758464481'))
4 (2^2.0), minintpow2 91.6142578125 (256/2.794325 or exp(log(256)/1.227464), minirrpow2 91.8935546875 (256/2.785832 or exp(log(256)/1.226638), precision 256
1574 (2^10.62022), minintdist mpf('8.51362139896553452e-51') = mpmath.power(2, mpmath.mpf('-166.328559904407132'))
1574 (2^10.62022), minirrdist mpf('5.10630170698518611e-50') = mpmath.power(2, mpmath.mpf('-163.744125962143644'))
1574 (2^10.62022), minintpow2 94.3994140625 (256/2.711881 or exp(log(256)/1.219381), minirrpow2 94.083984375 (256/2.720973 or exp(log(256)/1.220279), precision 256
619772 (2^19.241378), minintdist mpf('5.34650093639009184e-49') = mpmath.power(2, mpmath.mpf('-160.355881633338525'))
619772 (2^19.241378), minirrdist mpf('1.99798487228631293e-47') = mpmath.power(2, mpmath.mpf('-155.132074799879072'))
619772 (2^19.241378), minintpow2 95.89453125 (256/2.6696 or exp(log(256)/1.215182), minirrpow2 94.4853515625 (256/2.709415 or exp(log(256)/1.219137), precision 256
243959929 (2^27.862069), minintdist mpf('1.02016248121665617e-47') = mpmath.power(2, mpmath.mpf('-156.101821511257087'))
243959929 (2^27.862069), minirrdist mpf('5.67821481239887386e-45') = mpmath.power(2, mpmath.mpf('-146.98132684127752'))
243959929 (2^27.862069), minintpow2 97.4140625 (256/2.627957 or exp(log(256)/1.21101), minirrpow2 96.1015625 (256/2.663848 or exp(log(256)/1.214608), precision 256
96029500394 (2^36.482759), minintdist mpf('3.48652336501863663e-47') = mpmath.power(2, mpmath.mpf('-154.328831309794049'))
96029500394 (2^36.482759), minirrdist mpf('7.61520341966572826e-43') = mpmath.power(2, mpmath.mpf('-139.914025505213775'))
96029500394 (2^36.482759), minintpow2 97.7646484375 (256/2.618533 or exp(log(256)/1.21006), minirrpow2 95.931640625 (256/2.668567 or exp(log(256)/1.215079), precision 256
37799916363473 (2^45.103448), minintdist mpf('6.68542614650384676e-45') = mpmath.power(2, mpmath.mpf('-146.745744745535951'))
37799916363473 (2^45.103448), minirrdist mpf('7.36103848703998103e-41') = mpmath.power(2, mpmath.mpf('-133.319142575945487'))
37799916363473 (2^45.103448), minintpow2 97.533203125 (256/2.624747 or exp(log(256)/1.210686), minirrpow2 96.0673828125 (256/2.664796 or exp(log(256)/1.214702), precision 256

4 (2^2.0), minintdist mpf('3.63061980426069468e-104') = mpmath.power(2, mpmath.mpf('-343.620306008163056'))
4 (2^2.0), minirrdist mpf('6.08243794055394731e-104') = mpmath.power(2, mpmath.mpf('-342.875872172943075'))
4 (2^2.0), minintpow2 177.791015625 (512/2.879786 or exp(log(512)/1.204168), minirrpow2 177.4951171875 (512/2.884586 or exp(log(512)/1.204556), precision 512
787110 (2^19.586206), minintdist mpf('6.19374118510228546e-101') = mpmath.power(2, mpmath.mpf('-332.8839264845585'))
787110 (2^19.586206), minirrdist mpf('9.05916309446108897e-99') = mpmath.power(2, mpmath.mpf('-325.691503616782669'))
787110 (2^19.586206), minintpow2 182.458984375 (512/2.80611 or exp(log(512)/1.198174), minirrpow2 182.3193359375 (512/2.808259 or exp(log(512)/1.19835), precision 512
154885785622 (2^37.172414), minintdist mpf('1.01443332582273151e-97') = mpmath.power(2, mpmath.mpf('-322.206351157772989'))
154885785622 (2^37.172414), minirrdist mpf('2.54087789128431256e-94') = mpmath.power(2, mpmath.mpf('-310.915913874942304'))
154885785622 (2^37.172414), minintpow2 182.447265625 (512/2.80629 or exp(log(512)/1.198189), minirrpow2 181.802734375 (512/2.816239 or exp(log(512)/1.199004), precision 512
30478062041312124 (2^54.758621), minintdist mpf('7.82108089527331953e-95') = mpmath.power(2, mpmath.mpf('-312.615801008494584'))
30478062041312124 (2^54.758621), minirrdist mpf('5.15815351169621049e-91') = mpmath.power(2, mpmath.mpf('-299.928601924967705'))
30478062041312124 (2^54.758621), minintpow2 183.087890625 (512/2.796471 or exp(log(512)/1.197383), minirrpow2 183.3779296875 (512/2.792048 or exp(log(512)/1.197019), precision 512
5997401647012267425792 (2^72.344828), minintdist mpf('2.13050272570871753e-92') = mpmath.power(2, mpmath.mpf('-304.526190832374227'))
5997401647012267425792 (2^72.344828), minirrdist mpf('4.76751741693362964e-86') = mpmath.power(2, mpmath.mpf('-283.432577951239655'))
5997401647012267425792 (2^72.344828), minintpow2 182.8916015625 (512/2.799472 or exp(log(512)/1.197629), minirrpow2 183.03515625 (512/2.797277 or exp(log(512)/1.197449), precision 512
1180154645883665818180386816 (2^89.931034), minintdist mpf('1.88926956609974126e-89') = mpmath.power(2, mpmath.mpf('-294.733771880925411'))
1180154645883665818180386816 (2^89.931034), minirrdist mpf('2.56405403306425446e-82') = mpmath.power(2, mpmath.mpf('-271.039677116150088'))
1180154645883665818180386816 (2^89.931034), minintpow2 182.91015625 (512/2.799188 or exp(log(512)/1.197606), minirrpow2 184.052734375 (512/2.781811 or exp(log(512)/1.196176), precision 512

4 (2^2.0), minintdist mpf('1.48352648656008453e-207') = mpmath.power(2, mpmath.mpf('-687.070084957071578'))
4 (2^2.0), minirrdist mpf('5.10023280877207602e-207') = mpmath.power(2, mpmath.mpf('-685.288552538836126'))
4 (2^2.0), minintpow2 348.7685546875 (1024/2.936045 or exp(log(1024)/1.183975), minirrpow2 348.380859375 (1024/2.939312 or exp(log(1024)/1.1842), precision 1024
154885785622 (2^37.172414), minintdist mpf('4.35529743230837562e-200') = mpmath.power(2, mpmath.mpf('-662.262847730642875'))
154885785622 (2^37.172414), minirrdist mpf('5.71372489600114676e-197') = mpmath.power(2, mpmath.mpf('-651.905403117636809'))
154885785622 (2^37.172414), minintpow2 352.734375 (1024/2.903034 or exp(log(1024)/1.181693), minirrpow2 352.9248046875 (1024/2.901468 or exp(log(1024)/1.181584), precision 1024
5997401647012267425792 (2^72.344828), minintdist mpf('2.21630476503492713e-195') = mpmath.power(2, mpmath.mpf('-646.627822222382925'))
5997401647012267425792 (2^72.344828), minirrdist mpf('1.18851473448131469e-188') = mpmath.power(2, mpmath.mpf('-624.273322049779067'))
5997401647012267425792 (2^72.344828), minintpow2 353.9990234375 (1024/2.892663 or exp(log(1024)/1.180972), minirrpow2 354.1953125 (1024/2.89106 or exp(log(1024)/1.18086), precision 1024
232228066448517703763433590095872 (2^107.517241), minintdist mpf('8.46754549696143507e-189') = mpmath.power(2, mpmath.mpf('-624.762466100227741'))
232228066448517703763433590095872 (2^107.517241), minirrdist mpf('1.5360506675213829e-180') = mpmath.power(2, mpmath.mpf('-597.327831274749335'))
232228066448517703763433590095872 (2^107.517241), minintpow2 355.921875 (1024/2.877036 or exp(log(1024)/1.179883), minirrpow2 355.5537109375 (1024/2.880015 or exp(log(1024)/1.180091), precision 1024
8992206628896364834114578052301820549660672 (2^142.689655), minintdist mpf('4.46255433784302914e-184') = mpmath.power(2, mpmath.mpf('-609.076899723195255'))
8992206628896364834114578052301820549660672 (2^142.689655), minirrdist mpf('2.46919047446190818e-171') = mpmath.power(2, mpmath.mpf('-566.745666094822311'))
8992206628896364834114578052301820549660672 (2^142.689655), minintpow2 357.2734375 (1024/2.866152 or exp(log(1024)/1.179122), minirrpow2 356.072265625 (1024/2.875821 or exp(log(1024)/1.179798), precision 1024
348191247050200187832943816988495522269615389191176192 (2^177.862069), minintdist mpf('1.46009881572074658e-178') = mpmath.power(2, mpmath.mpf('-590.757134879662948'))
348191247050200187832943816988495522269615389191176192 (2^177.862069), minirrdist mpf('9.57347308813459972e-163') = mpmath.power(2, mpmath.mpf('-538.215237062509927'))
348191247050200187832943816988495522269615389191176192 (2^177.862069), minintpow2 358.57421875 (1024/2.855755 or exp(log(1024)/1.178394), minirrpow2 354.00390625 (1024/2.892623 or exp(log(1024)/1.180969), precision 1024

4 (2^2.0), minintdist mpf('5.22062437414692846e-413') = mpmath.power(2, mpmath.mpf('-1369.57208082850204'))
4 (2^2.0), minirrdist mpf('4.40736857537476558e-412') = mpmath.power(2, mpmath.mpf('-1366.49445754355594'))
4 (2^2.0), minintpow2 689.9501953125 (2048/2.96833 or exp(log(2048)/1.166447), minirrpow2 689.9111328125 (2048/2.968498 or exp(log(2048)/1.166457), precision 2048
5997401647012267425792 (2^72.344828), minintdist mpf('9.21370341135259451e-401') = mpmath.power(2, mpmath.mpf('-1328.88938489142323'))
5997401647012267425792 (2^72.344828), minirrdist mpf('2.61754169723847754e-394') = mpmath.power(2, mpmath.mpf('-1307.45145686626028'))
5997401647012267425792 (2^72.344828), minintpow2 695.0732421875 (2048/2.946452 or exp(log(2048)/1.165128), minirrpow2 697.4599609375 (2048/2.936369 or exp(log(2048)/1.164518), precision 2048
8992206628896364834114578052301820549660672 (2^142.689655), minintdist mpf('4.98906272418351815e-389') = mpmath.power(2, mpmath.mpf('-1289.91126010367372'))
8992206628896364834114578052301820549660672 (2^142.689655), minirrdist mpf('5.00935988160127759e-377') = mpmath.power(2, mpmath.mpf('-1250.04226551135886'))
8992206628896364834114578052301820549660672 (2^142.689655), minintpow2 694.5908203125 (2048/2.948499 or exp(log(2048)/1.165252), minirrpow2 695.2685546875 (2048/2.945624 or exp(log(2048)/1.165078), precision 2048
13482468711604290716096770149231877978064139330389855008377012224 (2^213.034483), minintdist mpf('9.5995804440310887e-379') = mpmath.power(2, mpmath.mpf('-1255.74777660903308'))
13482468711604290716096770149231877978064139330389855008377012224 (2^213.034483), minirrdist mpf('1.17828907093562783e-359') = mpmath.power(2, mpmath.mpf('-1192.33549254403263'))
13482468711604290716096770149231877978064139330389855008377012224 (2^213.034483), minintpow2 696.3154296875 (2048/2.941196 or exp(log(2048)/1.16481), minirrpow2 695.9326171875 (2048/2.942814 or exp(log(2048)/1.164908), precision 2048
20214945014191930013340819770094283364076860349237129321258448291881398297541985959936 (2^283.37931), minintdist mpf('1.37913764110400544e-368') = mpmath.power(2, mpmath.mpf('-1222.00577247023352'))
20214945014191930013340819770094283364076860349237129321258448291881398297541985959936 (2^283.37931), minirrdist mpf('1.07563788767294367e-342') = mpmath.power(2, mpmath.mpf('-1135.99421597356879'))
20214945014191930013340819770094283364076860349237129321258448291881398297541985959936 (2^283.37931), minintpow2 698.197265625 (2048/2.933268 or exp(log(2048)/1.16433), minirrpow2 695.5595703125 (2048/2.944392 or exp(log(2048)/1.165004), precision 2048
30309286130593384559555323965198701283584195061713760619280616111453466306994200310500354942532862345216000 (2^353.724138), minintdist mpf('2.5328390344705289e-358') = mpmath.power(2, mpmath.mpf('-1187.90950257503749'))
30309286130593384559555323965198701283584195061713760619280616111453466306994200310500354942532862345216000 (2^353.724138), minirrdist mpf('8.11856248202498544e-326') = mpmath.power(2, mpmath.mpf('-1079.92733463489074'))
30309286130593384559555323965198701283584195061713760619280616111453466306994200310500354942532862345216000 (2^353.724138), minintpow2 698.302734375 (2048/2.932825 or exp(log(2048)/1.164303), minirrpow2 697.2666015625 (2048/2.937184 or exp(log(2048)/1.164568), precision 2048




fbase, maxden, iprec = 2, 48, 128
mpmath.mp.prec = iprec
number1 = mpmath.fsum([mpmath.power(fbase, i) for i in range(1, int(iprec/1.75) - 4, 2) if random.random() < 0.9])
number2 = mpmath.fsum([mpmath.power(fbase, i) for i in range(2, int(iprec/1.75) - 3, 2) if random.random() < 0.9])

fbase, maxden, iprec = 3, 48, 128
mpmath.mp.prec = iprec
number1 = mpmath.fsum([mpmath.power(fbase, i) for i in range(1, int(iprec/1.75) - 4, 2) if i <= int(mpmath.log(mpmath.power(2, mpmath.mp.prec), fbase)) and random.random() < 0.9])
number2 = mpmath.fsum([mpmath.power(fbase, i) for i in range(2, int(iprec/1.75) - 3, 2) if i <= int(mpmath.log(mpmath.power(2, mpmath.mp.prec), fbase)) and random.random() < 0.9])

fbase, maxden, iprec = 5, 48, 128
mpmath.mp.prec = iprec
number1 = mpmath.fsum([mpmath.power(fbase, i) for i in range(1, int(iprec/1.75) - 4, 2) if i <= int(mpmath.log(mpmath.power(2, mpmath.mp.prec), fbase)) and random.random() < 0.9])
number2 = mpmath.fsum([mpmath.power(fbase, i) for i in range(2, int(iprec/1.75) - 3, 2) if i <= int(mpmath.log(mpmath.power(2, mpmath.mp.prec), fbase)) and random.random() < 0.9])

fbase, maxden, iprec = 7, 48, 128
mpmath.mp.prec = iprec
number1 = mpmath.fsum([mpmath.power(fbase, i) for i in range(1, int(iprec/1.75) - 4, 2) if i <= int(mpmath.log(mpmath.power(2, mpmath.mp.prec), fbase)) and random.random() < 0.9])
number2 = mpmath.fsum([mpmath.power(fbase, i) for i in range(2, int(iprec/1.75) - 3, 2) if i <= int(mpmath.log(mpmath.power(2, mpmath.mp.prec), fbase)) and random.random() < 0.9])

fbase, maxden, iprec = 43, 48, 256
mpmath.mp.prec = iprec
number1 = mpmath.fsum([mpmath.power(fbase, i) for i in range(1, int(iprec/1.75) - 4, 2) if i <= int(mpmath.log(mpmath.power(2, mpmath.mp.prec), fbase)) and random.random() < 0.9])
number2 = mpmath.fsum([mpmath.power(fbase, i) for i in range(2, int(iprec/1.75) - 3, 2) if i <= int(mpmath.log(mpmath.power(2, mpmath.mp.prec), fbase)) and random.random() < 0.9])

fbase, maxden, iprec = 2*mpmath.e(), 48, 128
mpmath.mp.prec = iprec
number1 = mpmath.fsum([mpmath.power(fbase, i) for i in range(1, int(iprec/1.75) - 4, 2) if i <= int(mpmath.log(mpmath.power(2, mpmath.mp.prec), fbase)) and random.random() < 0.9])
number2 = mpmath.fsum([mpmath.power(fbase, i) for i in range(2, int(iprec/1.75) - 3, 2) if i <= int(mpmath.log(mpmath.power(2, mpmath.mp.prec), fbase)) and random.random() < 0.9])


fracs = [0]
for iden in range(2, maxden + 1):
    for inum in range(1, iden):
        if mpmath.fdiv(inum, iden) not in fracs:
            fracs.append(mpmath.fdiv(inum, iden))

def is_fraction(f, ilimit):
    imul = 4
    if mpmath.fmod(imul * f, 1) == 0:
        return 1
    frac2 = fractions.Fraction(float(f)).limit_denominator(ilimit)
    if mpmath.fmod(imul * f * frac2.denominator, 1) == 0:
        return 2
    frac3 = fractions.Fraction(float(f**2)).limit_denominator(ilimit**2)
    if mpmath.fmod(imul * f**2 * frac3.denominator, 1) == 0:
        return 3
    for sq in range(2, 163 + 1):
        frac4 = fractions.Fraction(float(f * mpmath.sqrt(sq))).limit_denominator(ilimit)
        if mpmath.fmod(imul * f * mpmath.sqrt(sq) * frac4.denominator, 1) == 0:
            return 4
    for sq in range(2, 163 + 1):
        frac5 = fractions.Fraction(float(f / mpmath.sqrt(sq))).limit_denominator(ilimit)
        if mpmath.fmod(imul * (f / mpmath.sqrt(sq)) * frac5.denominator, 1) == 0:
            return 5
    pi = mpmath.pi()
    for sq in range(2, 163 + 1):
        frac6 = fractions.Fraction(float(f * pi * mpmath.sqrt(sq))).limit_denominator(ilimit)
        if mpmath.fmod(imul * f * pi * mpmath.sqrt(sq) * frac6.denominator, 1) == 0:
            return 6
    for sq in range(2, 163 + 1):
        frac7 = fractions.Fraction(float(f / pi / mpmath.sqrt(sq))).limit_denominator(ilimit)
        if mpmath.fmod(imul * (f / pi / mpmath.sqrt(sq)) * frac7.denominator, 1) == 0:
            return 7
    return -1

str_z = lambda z: "mpmath.mpc('" + str(z.real) + "', '" + str(z.imag) + "')"
def str_found(op, sreal1, simag1, sreal2, simag2, z):
    if sreal1 in ["-0", "(-0)", "(0)"]:
        sreal1 = "0"
    if simag1 in ["-0", "(-0)", "(0)"]:
        simag1 = "0"
    if sreal2 in ["-0", "(-0)", "(0)"]:
        sreal2 = "0"
    if simag2 in ["-0", "(-0)", "(0)"]:
        simag2 = "0"
    iprec = mpmath.mp.prec
    mpmath.mp.prec = 128
    s = "found mpmath." + op + "(mpmath.mpc(" + sreal1 + ", " + simag1 + "), mpmath.mpc(" + sreal2 + ", " + simag2 + ")) = " + str_z(z)
    mpmath.mp.prec = iprec
    return s

def add_z(z):
    abs_zreal = abs(float(z.real))
    if abs_zreal not in [0, 1] and abs_zreal not in found_floats:
        found_floats.append(abs_zreal)
    abs_zimag = abs(float(z.imag))
    if abs_zimag not in [0, 1] and abs_zimag not in found_floats:
        found_floats.append(abs_zimag)

found_floats = []
mulimag = ["-1", "1", "-0.5 * mpmath.pi()", "0.5 * mpmath.pi()", "-mpmath.pi()", "mpmath.pi()", "2 * mpmath.pi()", "-2 * mpmath.pi()"]
bfirst = True
for i in range(0, len(fracs)):
    if bfirst:
        sbase = str(int(fbase)) if mpmath.fmod(fbase, 1) == 0 else str(fbase)
        snumber1 = str(int(number1)) if mpmath.fmod(number1, 1) == 0 else str(number1)
        snumber2 = str(int(number2)) if mpmath.fmod(number2, 1) == 0 else str(number2)
        print("fbase " + sbase + ", maxden " + str(maxden) + ", iprec " + str(iprec))
        print("number1 " + snumber1 + ", mpmath.power(" + sbase + ", mpmath.mpf('" + str(mpmath.log(number1, fbase)) + "'))")
        print("number2 " + snumber2 + ", mpmath.power(" + sbase + ", mpmath.mpf('" + str(mpmath.log(number2, fbase)) + "'))")
        if mpmath.fmod(fbase, 1) == 0 and mpmath.fmod(fbase, 2) != 0:
            mulimag.append(str(int(-fbase)) + " * mpmath.pi()")
            mulimag.append(str(int(fbase)) + " * mpmath.pi()")
            mulimag.append("(mpmath.pi() / " + str(int(fbase)) + ")")
            mulimag.append("(-mpmath.pi() / " + str(int(fbase)) + ")")
            mulimag.append(str(int(-fbase)) + " * 2 * mpmath.pi()")
            mulimag.append(str(int(fbase)) + " * 2 * mpmath.pi()")
            mulimag.append("(2 * mpmath.pi() / " + str(int(fbase)) + ")")
            mulimag.append("(-2 * mpmath.pi() / " + str(int(fbase)) + ")")
        bfirst = False
    for j in range(0, len(fracs)):
        fraci = 0 if fracs[i] == 0 else fractions.Fraction(float(fracs[i])).limit_denominator(maxden)
        fracj = 0 if fracs[j] == 0 else fractions.Fraction(float(fracs[j])).limit_denominator(maxden)
        for addthisi in range(-maxden, maxden + 1):
            for addthisj in range(-maxden, maxden + 1):
                sfraci = "0" if (fraci == 0 and addthisi == 0) else "" if (fraci == 0) else str(fraci.numerator) + "/" + str(fraci.denominator)
                sfracj = "0" if (fracj == 0 and addthisj == 0) else "" if (fracj == 0) else str(fracj.numerator) + "/" + str(fracj.denominator)
                for mulimagi in mulimag:
                    for mulimagj in mulimag:
                        z = mpmath.fdiv(mpmath.mpc(addthisi + fracs[i], eval(mulimagi) * number1), mpmath.mpc(addthisj + fracs[j], eval(mulimagj) * number2))
                        if is_fraction(z.real, 4*maxden) > 0 or is_fraction(z.imag, 4*maxden) > 0:
                            add_z(z)
                            sreal1 = ("" if addthisi == 0 else str(addthisi) + (" + " if sfraci != "" else "")) + sfraci
                            simag1 = ("" if mulimagi == "1" else mulimagi + " * ") + "number1"
                            sreal2 = ("" if addthisj == 0 else str(addthisj) + (" + " if sfracj != "" else "")) + sfracj
                            simag2 = ("" if mulimagj == "1" else mulimagj + " * ") + "number2"
                            print(str_found("fdiv", sreal1, simag1, sreal2, simag2, z))
                        if fracs[i] != 0 or fracs[j] != 0:
                            z = mpmath.fdiv(mpmath.mpc(addthisi - fracs[i], eval(mulimagi) * number1), mpmath.mpc(addthisj - fracs[j], eval(mulimagj) * number2))
                            if is_fraction(z.real, 4*maxden) > 0 or is_fraction(z.imag, 4*maxden) > 0:
                                add_z(z)
                                sreal1 = ("-" if (addthisi == 0 and sfraci != "0") else "" if (addthisi == 0) else str(addthisi) + (" - " if sfraci != "" else "")) + sfraci
                                simag1 = ("" if mulimagi == "1" else mulimagi + " * ") + "number1"
                                sreal2 = ("-" if (addthisj == 0 and sfracj != "0") else "" if (addthisj == 0) else str(addthisj) + (" - " if sfracj != "" else "")) + sfracj
                                simag2 = ("" if mulimagj == "1" else mulimagj + " * ") + "number2"
                                print(str_found("fdiv", sreal1, simag1, sreal2, simag2, z))
                        
                        z = mpmath.fdiv(mpmath.mpc(addthisi + fracs[i], eval(mulimagi) * number1), mpmath.mpc(number2, eval(mulimagj) * (addthisj + fracs[j])))
                        if is_fraction(z.real, 4*maxden) > 0 or is_fraction(z.imag, 4*maxden) > 0:
                            add_z(z)
                            sreal1 = ("" if addthisi == 0 else str(addthisi) + (" + " if sfraci != "" else "")) + sfraci
                            simag1 = ("" if mulimagi == "1" else mulimagi + " * ") + "number1"
                            sreal2 = "number2"
                            simag2 = ("" if mulimagj == "1" else mulimagj + " * ") + "(" + ("" if addthisj == 0 else str(addthisj) + (" + " if sfracj != "" else "")) + sfracj + ")"
                            print(str_found("fdiv", sreal1, simag1, sreal2, simag2, z))
-                        if fracs[i] != 0 or fracs[j] != 0:
                            z = mpmath.fdiv(mpmath.mpc(addthisi - fracs[i], eval(mulimagi) * number1), mpmath.mpc(number2, eval(mulimagj) * (addthisj - fracs[j])))
                            if is_fraction(z.real, 4*maxden) > 0 or is_fraction(z.imag, 4*maxden) > 0:
                                add_z(z)
                                sreal1 = ("-" if (addthisi == 0 and sfraci != "0") else "" if (addthisi == 0) else str(addthisi) + (" - " if sfraci != "" else "")) + sfraci
                                simag1 = ("" if mulimagi == "1" else mulimagi + " * ") + "number1"
                                sreal2 = "number2"
                                simag2 = ("" if mulimagj == "1" else mulimagj + " * ") + "(" + ("-" if (addthisj == 0 and sfraj != "0") else "" if (addthisj == 0) else str(addthisj) + (" - " if sfracj != "" else "")) + sfracj + ")"
                                print(str_found("fdiv", sreal1, simag1, sreal2, simag2, z))
                        
                        z = mpmath.log(mpmath.mpc(addthisi + fracs[i], eval(mulimagi) * number1), mpmath.mpc(addthisj + fracs[j], eval(mulimagj) * number2))
                        if is_fraction(z.real, 4*maxden) > 0 or is_fraction(z.imag, 4*maxden) > 0:
                            add_z(z)
                            sreal1 = ("" if addthisi == 0 else str(addthisi) + (" + " if sfraci != "" else "")) + sfraci
                            simag1 = ("" if mulimagi == "1" else mulimagi + " * ") + "number1"
                            sreal2 = ("" if addthisj == 0 else str(addthisj) + (" + " if sfracj != "" else "")) + sfracj
                            simag2 = ("" if mulimagj == "1" else mulimagj + " * ") + "number2"
                            print(str_found("log", sreal1, simag1, sreal2, simag2, z))
                        if fracs[i] != 0 or fracs[j] != 0:
                            z = mpmath.log(mpmath.mpc(addthisi - fracs[i], eval(mulimagi) * number1), mpmath.mpc(addthisj - fracs[j], eval(mulimagj) * number2))
                            if is_fraction(z.real, 4*maxden) > 0 or is_fraction(z.imag, 4*maxden) > 0:
                                add_z(z)
                                sreal1 = ("-" if (addthisi == 0 and sfraci != "0") else "" if (addthisi == 0) else str(addthisi) + (" - " if sfraci != "" else "")) + sfraci
                                simag1 = ("" if mulimagi == "1" else mulimagi + " * ") + "number1"
                                sreal2 = ("-" if (addthisj == 0 and sfracj != "0") else "" if (addthisj == 0) else str(addthisj) + (" - " if sfracj != "" else "")) + sfracj
                                simag2 = ("" if mulimagj == "1" else mulimagj + " * ") + "number2"
                                print(str_found("log", sreal1, simag1, sreal2, simag2, z))
                         
                        z = mpmath.log(mpmath.mpc(addthisi + fracs[i], eval(mulimagi) * number1), mpmath.mpc(number2, eval(mulimagj) * (addthisj + fracs[j])))
                        if is_fraction(z.real, 4*maxden) > 0 or is_fraction(z.imag, 4*maxden) > 0:
                            add_z(z)
                            sreal1 = ("" if addthisi == 0 else str(addthisi) + (" + " if sfraci != "" else "")) + sfraci
                            simag1 = ("" if mulimagi == "1" else mulimagi + " * ") + "number1"
                            sreal2 = "number2"
                            simag2 = ("" if mulimagj == "1" else mulimagj + " * ") + "(" + ("" if addthisj == 0 else str(addthisj) + (" + " if sfracj != "" else "")) + sfracj + ")"
                            print(str_found("log", sreal1, simag1, sreal2, simag2, z))
                        if fracs[i] != 0 or fracs[j] != 0:
                            z = mpmath.log(mpmath.mpc(addthisi - fracs[i], eval(mulimagi) * number1), mpmath.mpc(number2, eval(mulimagj) * (addthisj + fracs[j])))
                            if is_fraction(z.real, 4*maxden) > 0 or is_fraction(z.imag, 4*maxden) > 0:
                                add_z(z)
                                sreal1 = ("-" if (addthisi == 0 and sfraci != "0") else "" if (addthisi == 0) else str(addthisi) + (" - " if sfraci != "" else "")) + sfraci
                                simag1 = ("" if mulimagi == "1" else mulimagi + " * ") + "number1"
                                sreal2 = "number2"
                                simag2 = ("" if mulimagj == "1" else mulimagj + " * ") + "(" + ("-" if (addthisj == 0 and sfracj != "0") else "" if (addthisj == 0) else str(addthisj) + (" - " if sfracj != "" else "")) + sfracj + ")"
                                print(str_found("log", sreal1, simag1, sreal2, simag2, z))





